r"""@file   md_delinblocks.py@author Peter M Bach <peterbach@gmail.com>@section LICENSEUrban Biophysical Environments and Technologies Simulator (UrbanBEATS)Copyright (C) 2018  Peter M. BachThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>."""__author__ = "Peter M. Bach"__copyright__ = "Copyright 2018. Peter M. Bach"# --- CODE STRUCTURE ---#       (1) Class Definition#           1.1 __init__() - primarily for parameter list#           1.2 run() - the module algorithm#           1.3 supplementary functions - all other modularised functions belonging to the module# --- --- --- --- --- ---# --- PYTHON LIBRARY IMPORTS ---import mathimport random as randimport threadingimport osimport mathimport sysimport numpy as npimport timefrom shapely.geometry import Polygon, LineString, Pointimport shapely.geometryfrom rasterio import features# --- URBANBEATS LIBRARY IMPORTS ---from .ubmodule import *import model.ublibs.ubspatial as ubspatialimport model.ublibs.ubmethods as ubmethodsimport model.ublibs.ubdatatypes as ubdataimport model.progref.ubglobals as ubglobals# --- MODULE SPECIFIC IMPORTS ---from .lib_delineation import squaregrid as squaregridfrom .lib_delineation import hexgrid as hexgrid# --- LIBRARY SETTINGS ---np.set_printoptions(threshold=sys.maxsize, linewidth=5000)      # Numpy Print Options -- DEBUG# --- MODULE CLASS DEFINITION ---class DelinBlocks(UBModule):    """ SPATIAL SETUP MODULE - Codename: DelinBlocks    Loads the spatial maps into the model core and processes them into Blocks. Also performs spatial connectivity    analysis and prepares all spatial input data in a ready-to-use format for all other modules. Links loaded data    sets into the model.    """    def __init__(self, activesim, scenario, datalibrary, projectlog, simulationyear):        """Initialises UBModule followed by full parameter list definition."""        UBModule.__init__(self)        self.name = "Delineation and Spatial Setup Module"        self.simulationyear = simulationyear        # CONNECTIONS WITH CORE SIMULATION        self.activesim = activesim      # The current active UBSimulation() object from urbanbeatscore.py        self.scenario = scenario        # The current active UBScenario() object        self.datalibrary = datalibrary  # The active data library UBDataLibrary()        self.projectlog = projectlog    # Active project log        # PARAMETER LIST DEFINITION        # (Tab 1.1) ESSENTIAL SPATIAL DATA SETS        self.create_parameter("landuse_map", STRING, "land use map filepath")        self.create_parameter("population_map", STRING, "population map filepath")        self.create_parameter("elevation_map", STRING, "elevation map filepath")        self.create_parameter("landuse_fud", BOOL, "use urban development land use?")        self.create_parameter("population_fud", BOOL, "use urban development population?")        self.landuse_map = ""        self.population_map = ""        self.elevation_map = ""        self.landuse_fud = 0        self.population_fud = 0        self.create_parameter("population_corr", BOOL, "Apply a population correction factor?")        self.create_parameter("population_scale", DOUBLE, "Scaling factor for population")        self.create_parameter("population_scale_auto", BOOL, "Auto-determine scaling factor?")        self.create_parameter("dem_smooth", BOOL, "smooth DEM map before doing flowpath delineation?")        self.create_parameter("dem_passes", DOUBLE, "number of passes for smoothing")        self.population_corr = 0        self.population_scale = 1.0        self.population_scale_auto = 0        self.dem_smooth = 0        self.dem_passes = 1        # (Tab 1.2) SPATIAL GEOMETRY        self.create_parameter("geometry_type", STRING, "block or future types of geometry e.g. hex")        self.geometry_type = "SQUARES"  # SQUARES, HEXAGONS, VECTORPATCH        # 1.2.1 BLOCKS        self.create_parameter("blocksize", DOUBLE, "resolution of the discretisation grid")        self.create_parameter("blocksize_auto", BOOL, "determine resolution automatically?")        self.create_parameter("patchdelin_sq", BOOL, "delineate patches for square blocks?")        self.create_parameter("spatialmetrics_sq", BOOL, "calculate spatial metrics for square blocks?")        self.create_parameter("neighbourhood", STRING, "type of neighbourhood to use, Moore or vN")        self.create_parameter("min_edge_length", DOUBLE, "minimum shared edge length")        self.create_parameter("min_edge_auto", BOOL, "auto-determine minimum shared edge length")        self.blocksize = 500        self.blocksize_auto = 0        self.patchdelin_sq = 0        self.spatialmetrics_sq = 0        self.neighbourhood = "M"    # M (Moore) or V (von Neumann)        self.min_edge_length = 100.0        self.min_edge_auto = 0        # 1.2.2 HEXAGONS        self.create_parameter("hexsize", DOUBLE, "side of a single hexagon cell")        self.create_parameter("hexsize_auto", BOOL, "auto-determine hexgrid resolution?")        self.create_parameter("hex_orientation", STRING, "orientation of the hex grid")        self.create_parameter("patchdelin_hex", BOOL, "delineate patches for square blocks?")        self.create_parameter("spatialmetrics_hex", BOOL, "calculate spatial metrics for square blocks?")        self.hexsize = 500        self.hexsize_auto = 0        self.hex_orientation = "NS"     # NS = north-south, EW = east-west        self.patchdelin_hex = 0        self.spatialmetrics_hex = 0        # 1.2.3 VECTORPATCHES        self.create_parameter("disgrid_shape", STRING, "Shape of the discretization grid")        self.create_parameter("disgrid", DOUBLE, "Discretisation grid for patches")        self.create_parameter("disgrid_auto", BOOL, "Auto-determine discretization grid?")        self.disgrid_shape = "SQ"       # SQ = Squares, HNS = HexNorth-South, HEW = HexEast-West        self.disgrid = 500        self.disgrid_auto = 0        # (Tab 2.1) JURISDICTIONAL AND SUBURBAN BOUNDARIES        self.create_parameter("include_geopolitical", BOOL, "include geopolitical map?")        self.create_parameter("geopolitical_map", STRING, "geopolitical map filepath")        self.create_parameter("geopolitical_attref", STRING, "attribute name reference")        self.create_parameter("include_suburb", BOOL, "include suburban map?")        self.create_parameter("suburban_map", STRING, "suburban map filepath")        self.create_parameter("suburban_attref", STRING, "attribute name reference")        self.create_parameter("include_planzone", BOOL, "include suburban map?")        self.create_parameter("planzone_map", STRING, "suburban map filepath")        self.create_parameter("planzone_attref", STRING, "attribute name reference")        self.include_geopolitical = 0        self.geopolitical_map = ""        self.geopolitical_attref = ""        self.include_suburb = 0        self.suburban_map = ""        self.suburban_attref = ""        self.include_planzone = 0        self.planzone_map = ""        self.planzone_attref = ""        # (Tab 2.2) CENTRAL BUSINESS DISTRICT        self.create_parameter("considerCBD", BOOL, "consider CBD Location?")        self.create_parameter("locationOption", STRING, "method for inputting CBD location")        self.create_parameter("locationCity", STRING, "city name")        self.create_parameter("locationLong", DOUBLE, "CBD Longitude")        self.create_parameter("locationLat", DOUBLE, "CBD Latitude")        self.create_parameter("marklocation", BOOL, "mark location on output map")        self.considerCBD = 0        self.locationOption = "S"   # S = Selection, C = coordinates        self.locationCity = self.activesim.get_project_parameter("city")        self.locationLong = float(0.0)        self.locationLat = float(0.0)        self.marklocation = 0        # (Tab 3.1) MAJOR WATER FEATURES        self.create_parameter("include_rivers", BOOL, "include a rivers map into simulation?")        self.create_parameter("include_lakes", BOOL, "include a ponds and lakes map into simulation?")        self.create_parameter("calculate_wbdistance", BOOL, "calculate distance to closest water body?")        self.create_parameter("river_map", STRING, "river map data reference ID")        self.create_parameter("river_attname", STRING, "river map identifier attribute name")        self.create_parameter("lake_map", STRING, "ponds and lake map data reference ID")        self.create_parameter("lake_attname", STRING, "lake map identifier attribute name")        self.include_rivers = 0        self.include_lakes = 0        self.calculate_wbdistance = 0        self.river_map = ""        self.river_attname = ""        self.lake_map = ""        self.lake_attname = ""        # (Tab 3.2) BUILT WATER INFRASTRUCTURE #[TO DO]        self.create_parameter("include_storm", BOOL, "include stormwater drainage infrastructure")        self.create_parameter("include_sewer", BOOL, "include wastewater infrastructure")        self.create_parameter("include_supply", BOOL, "include water supply infrastructure")        self.create_parameter("storm_map", STRING, "stormwater drainage infrastructure map data reference ID")        self.create_parameter("sewer_map", STRING, "sewer infrastructure map data reference ID")        self.create_parameter("supply_map", STRING, "water supply map data reference ID")        self.include_storm = 0        self.include_sewer = 0        self.include_supply = 0        self.storm_map = ""        self.sewer_map = ""        self.supply_map = ""        # (Tab 3.3) STORMWATER DRAINAGE FLOW PATHS        self.create_parameter("flowpaths", BOOL, "delineate drainage flow paths and subcatchments?")        self.create_parameter("flowpath_method", STRING, "flowpath method to use")        self.create_parameter("guide_natural", BOOL, "guide flowpath delineation using pre-loaded natural feature?")        self.create_parameter("guide_built", BOOL, "guide flowpath delineation using built infrastructure?")        self.create_parameter("ignore_rivers", BOOL, "ignore river features in the delineation of outlets")        self.create_parameter("ignore_lakes", BOOL, "ignore lake features in the delineation of outlets")        self.flowpaths = 1        self.flowpath_method = "D8"        self.guide_natural = 0        self.guide_built = 0        self.ignore_rivers = 0        self.ignore_lakes = 0        # --------------------------------------------------------------------------------------------------------------        # ADVANCED / EXPERIMENTAL PARAMETER LIST        # Hexagonal Neighbourhoods        self.create_parameter("hex_neighbourhood", STRING, "neighbourhood rule for hexagon")        self.hex_neighbourhood = "ISO"  # Unchanged in the user interface unless through advanced parameters        # ISO = isotropic (6), YINV = inverse Y (3), YNOR = normal Y (3), NOR = non-ortho (4)        # Open Space Networks (Superseeded by Spatial Mapping Module)        self.create_parameter("osnet_accessibility", BOOL, "Calculate accessibility?")        self.create_parameter("osnet_network", BOOL, "Delineate open space network?")        self.osnet_accessibility = 0        self.osnet_network = 0        # Patch Flow Paths        self.create_parameter("patchflowpaths", BOOL, "delineate drainage flow paths for patches?")        self.create_parameter("patchflowmethod", STRING, "flowpath method to use")        self.create_parameter("patchsearchradius", DOUBLE, "search radius to use for the patch flow paths?")        self.create_parameter("patchsearchauto", BOOL, "auto-determine the search radius?")        self.patchflowpaths = 1        self.patchflowmethod = "MAX"  # MAX = max drop, MIN = min drop, DIST = closest distance drop        self.patchsearchradius = 500.0        self.patchsearchauto = 1  # Auto == True --> 1.4 Block size        # --------------------------------------------------------------------------------------------------------------        # NON-VISIBLE PARAMETER LIST - USED THROUGHOUT THE SIMULATION        self.xllcorner = float(0.0)     # Obtained from the loaded raster data (elevation) upon run-time        self.yllcorner = float(0.0)     # Spatial extents of the input map        self.final_bs = self.blocksize  # Final_bs = final block size - this is determined at the start        self.spatialmetrics = 0        self.patchdelin = 0        self.map_attr = None        self.elevation = 0        self.landuse = 0        self.population = 0        self.municipal_boundary = 0        self.suburban_boundary = 0        # ----- END OF INPUT PARAMETER LIST -----    def run_module(self):        """Contains the main algorithm for the module, links with all other functions thereafter. This is called by        UrbanBEATSSim() simulation's scenario manager depending on which scenario is currently being simulated.        :return: True upon successful completion        """        self.notify("Start Spatial Delineation Module")     # Module start        rand.seed()     # Seed the random number generator        # --- SECTION 1 - PREPARATION FOR CREATING THE GRIDDED MAP BASED ON THE INPUT BOUNDARY MAP ---        # GET BOUNDARY EXTENTS AND WORK OUT THE MAP DIMENSIONS        xmin, xmax, ymin, ymax = self.activesim.get_scenario_boundary_info("mapextents")        mapwidth = xmax - xmin  # width of the map [m]        mapheight = ymax - ymin  # height of map [m]        Amap_rect = mapwidth * mapheight  # Total area of the rectangular extents [m]        self.notify("Map Width [km] = " + str(mapwidth / 1000.0))        self.notify("Map Height [km] = " + str(mapheight / 1000.0))        self.notify("Extent Area WxH [km2] = " + str(Amap_rect / 1000000.0))        self.notify("---===---")        # MAP ATTRIBUTES - CREATE THE FIRST UBCOMPONENT() to save off basic map attributes.        self.map_attr = ubdata.UBComponent()        self.map_attr.add_attribute("xllcorner", xmin)  # The geographic coordinate x-pos of the actual map        self.map_attr.add_attribute("yllcorner", ymin)  # The geographic coordinate y-pos of the actual map        self.map_attr.add_attribute("considerCBD", self.considerCBD)        self.scenario.add_asset("MapAttributes", self.map_attr)        # CBD DISTANCE CALCULATIONS [TO DO]        # Look up long and lat of CBD if need to be considered - convert to project coordinate system of project        if self.considerCBD:  # [TO DO]            # Grab CBD Coordinates and transform to the local coordinate system            pass        if self.marklocation:            # Mark locations on the map            pass        # START CREATING BLOCKS MAP        self.notify("Creating Blocks Map!")        # Call respective functions based on type of delineation        if self.geometry_type == "SQUARES":     # ---- SQUARE GRIDS -----            numblocks, blocks_wide, blocks_tall, self.final_bs = squaregrid.\                determine_number_of_squares(mapwidth, mapheight, self.blocksize, self.blocksize_auto)            nhd_type = self.neighbourhood            blockarea = pow(self.final_bs, 2)            self.spatialmetrics = self.spatialmetrics_sq            self.patchdelin = self.patchdelin_sq        elif self.geometry_type == "HEXAGONS":  # ---- HEXAGONAL GRIDS ----            numblocks, blocks_wide, blocks_tall, self.final_bs = hexgrid.\                determine_number_of_hexes(mapwidth, mapheight, self.hexsize, self.hex_orientation,                                          self.hexsize_auto)            nhd_type = self.hex_neighbourhood            blockarea = pow(self.final_bs, 2) * 0.5 * 3.0 * math.sqrt(3.0)            self.spatialmetrics = self.spatialmetrics_hex            self.patchdelin = self.patchdelin_hex        elif self.geometry_type == "VECTORPATCH":    # ---- VECTOR-BASED PATCH GRID ----            if self.disgrid_shape == "SQ":  # SQUARE DISCRETIZATION GRID                numblocks, blocks_wide, blocks_tall, self.final_bs = squaregrid.\                    determine_number_of_squares(mapwidth, mapheight, self.disgrid, self.disgrid_auto)            elif self.disgrid_shape == "HNS":   # HEXAGONAL NORTH-SOUTH DISCRETIZATION GRID                numblocks, blocks_wide, blocks_tall, self.final_bs = hexgrid.\                    determine_number_of_hexes(mapwidth, mapheight, self.disgrid, "NS", self.disgrid_auto)            else:   # HEXAGONAL EAST-WEST DISCRETIZATION GRID                numblocks, blocks_wide, blocks_tall, self.final_bs = hexgrid. \                    determine_number_of_hexes(mapwidth, mapheight, self.disgrid, "EW", self.disgrid_auto)            nhd_type = "DIRICHLET"            blockarea = 0            self.spatialmetrics = 0            self.patchdelin = 0        else:            blocks_wide = 0            blocks_tall = 0            numblocks = 0            blockarea = 0        if self.geometry_type in ["SQUARES", "HEXAGONS"]:       # A global tracking of idtype so the program knows            self.map_attr.add_attribute("idtype", "BlockID")    # what the main asset type is. Squares and Hexes are        elif self.geometry_type == "VECTORPATCH":               # saved to BlockID, whereas Vectorpatches are saved to            self.map_attr.add_attribute("idtype", "PatchID")    # PatchID.        # REPORTING        self.notify("Geometry: "+str(self.geometry_type))        self.notify("Blocks wide: "+str(blocks_wide))        self.notify("Blocks tall: "+str(blocks_tall))        self.notify("Total number of Blocks: "+str(numblocks))        self.notify("Final Block Size [m] = " + str(self.final_bs))        # Attributes for Block-based Representation        self.map_attr.add_attribute("NumBlocks", numblocks)        self.map_attr.add_attribute("BlocksWide", blocks_wide)        self.map_attr.add_attribute("BlocksTall", blocks_tall)  # Height of simulation area in # of blocks        self.map_attr.add_attribute("BlockSize", self.final_bs)  # Size of block [m]        self.map_attr.add_attribute("BlockArea", blockarea)     # Area of a Block [sqm] if uniform grid        self.map_attr.add_attribute("Neigh_Type", nhd_type)        self.map_attr.add_attribute("GeometryType", self.geometry_type)     # SQUARES, HEXAGONS, VECTORPATCH        # --- SECTION 2 - DRAW THE MAP OF BLOCKS AND DETERMINE ACTIVE AND INACTIVE BLOCKS , NEIGHBOURHOODS ---        # Get the coordinates for the boundary of the map, this is used to check if the Block is active or inactive        boundarygeom = self.activesim.get_scenario_boundary_info("coordinates")        boundarygeom_zeroorigin = []    # Contains the polygon's coordinates shifted to the zero origin        for coord in boundarygeom:      # Shift the map to (0,0) origin            boundarygeom_zeroorigin.append((coord[0] - xmin, coord[1] - ymin))        boundarypoly = Polygon(boundarygeom_zeroorigin)     # Test intersect with Block Polygon later using        blockIDcount = 1    # Counter for BlockID, initialized here        blockslist = []        self.notify("Creating Block Geometry ... ")        print(self.geometry_type, self.disgrid_shape)        for y in range(blocks_tall):        # Loop across the number of blocks tall and blocks wide            for x in range(blocks_wide):                # - STEP 1 - CREATE BLOCK GEOMETRY                if (self.geometry_type == "SQUARES") or \                        (self.geometry_type == "VECTORPATCH" and self.disgrid_shape == "SQ"):                    current_block = squaregrid.create_block_geometry(x, y, self.final_bs, blockIDcount, boundarypoly)                elif (self.geometry_type == "HEXAGONS" and self.hex_orientation == "NS") or \                        (self.geometry_type == "VECTORPATCH" and self.disgrid_shape == "HNS"):                    current_block = hexgrid.create_hex_geometry_ns(x, y, self.final_bs, mapheight,                                                                blocks_tall, blockIDcount, boundarypoly)                elif (self.geometry_type == "HEXAGONS" and self.hex_orientation == "EW") or \                        (self.geometry_type == "VECTORPATCH" and self.disgrid_shape == "HEW"):                    current_block = hexgrid.create_hex_geometry_ew(x, y, self.final_bs, blockIDcount, boundarypoly)                else:                    current_block = None                    self.notify("No legal geometry specified")                if current_block is None:                    blockIDcount += 1                    continue                self.scenario.add_asset("BlockID"+str(blockIDcount), current_block)     # Add the asset to the scenario                blockslist.append(current_block)                blockIDcount += 1       # Increase the Block ID Count by one        # - STEP 2 - GET BASIC RASTER DATA SETS AND ADD TO BLOCKS        # Depending on what's available, certain options can be chosen        #   - Land use: + population, will allow the model to do urban planning        #   - Elevation: will allow the model to do Flowpath delineation        self.notify("Block Geometry Established")        self.notify("Loading Basic Input Maps")        # STEP 2.1 :: Get data references for all loaded maps        # (1) LAND USE MAP        if self.landuse_map:            luc_dref, landuseraster, landuse_offset, luc_res, luc_cscx, luc_cscy = \                self.import_data_for_input_raster_map(self.landuse_map)        else:            landuseraster = None  # Indicate that the simulation has no land use data, limits what can be done            luc_res = None            landuse_offset = None            luc_cscx = None            luc_cscy = None            self.map_attr.set_attribute("HasLUC", 0)            self.map_attr.add_attribute("HasSPATIALMETRICS", 0)        # (2) POPULATION MAP        if self.population_map:            pop_dref, populationraster, population_offset, pop_res, pop_cscx, pop_cscy = \                self.import_data_for_input_raster_map(self.population_map)            # In the population map, all no-data values can be replaced by zeros            populationraster.replace_nodatavalues(0)            # Get the total map population for validation purposes!            if pop_dref.get_metadata("sub") == "Density":                total_data_pop = int(populationraster.get_raster_sum() * (pow(pop_res, 2) / 10000.0))  # DENSITY            else:                total_data_pop = int(populationraster.get_raster_sum())  # COUNT            self.map_attr.set_attribute("VAL_TotalPop", total_data_pop)            self.notify("Total Map Population = " + str(total_data_pop))        else:            populationraster = None  # Indicates that the simulation has no population data, limits features            population_offset = None            pop_cscx = None            pop_cscy = None            pop_res = None            self.map_attr.set_attribute("HasPOP", 0)            self.map_attr.set_attribute("VAL_TotalPop", 0)        # (3) ELEVATION MAP        if self.elevation_map:            elev_dref, elevationraster, elevation_offset, elev_res, elev_cscx, elev_cscy = \                self.import_data_for_input_raster_map(self.elevation_map)        else:            elevationraster = None  # Indicates that the simulation has no elevation data, many water features disabled            elevation_offset = None            elev_cscx = None            elev_cscy = None            elev_res = None            self.map_attr.set_attribute("HasELEV", 0)        # - STEP 2.2 :: Aggregate data to Blocks / Patches        self.notify("Assigning Raster Data to Blocks")        # For Vectorpatches only        patchIDtracker = 0      # To track the PatchIDs throughout the simulation        map_population = 0      # Tracks the population across the map to work out correction factor if AUTO        for i in range(len(blockslist)):            current_block = blockslist[i]            self.notify("Current BLOCK ID: " + str(current_block.get_attribute("BlockID")))            # Bottom left-hand corner            originXY = [current_block.get_attribute("OriginX"), current_block.get_attribute("OriginY")]            # LAND USE TO BLOCKS            if self.landuse_map:                self.map_attr.set_attribute("HasLUC", 1)                nodatavalue = landuseraster.get_nodatavalue()                lucdatamatrix, dataXY = self.get_data_matrix_from_input_raster(                    current_block, landuseraster, landuse_offset, luc_res, luc_cscx, luc_cscy)                if self.geometry_type == "SQUARES":                    self.process_landuse_datamatrix_for_current_block(current_block, lucdatamatrix, nodatavalue, 0)                    blockstatus = current_block.get_attribute("Status")                elif self.geometry_type == "HEXAGONS":                    # Based on the hexagon, work out the intersect                    hexpoly = [p[:2] for p in current_block.get_points()]                    lucadj, cmo = self.create_raster_mask_for_hexagon(                        lucdatamatrix, Polygon(hexpoly), dataXY, landuseraster.get_cellsize(), nodatavalue)                    # cmo = cells masked out - number of cells that do not belong within the region at all                    self.process_landuse_datamatrix_for_current_block(current_block, lucadj, nodatavalue, cmo)                    blockstatus = current_block.get_attribute("Status")                elif self.geometry_type == "VECTORPATCH":                    # Based on the lucdatamatrix for the current square, create the patches                    patchlist, patchIDs, patchIDtracker = self.create_vector_patches(current_block, patchIDtracker,                                                                                     lucdatamatrix,                                                                                     landuseraster.get_cellsize(),                                                                                     nodatavalue)                    for patch in patchlist:     # Add all patches to the asset collection                        self.scenario.add_asset("PatchID" + str(patch.get_attribute("PatchID")), patch)                    current_block.add_attribute("PatchIDs", patchIDs)                    blockstatus = 1                else:                    pass            else:                blockstatus = 0            # Land use patch delineation - 4 conditions to proceed            if self.landuse_map and self.patchdelin and blockstatus and self.geometry_type != "VECTORPATCH":                patchIDs = []                if self.geometry_type == "SQUARES":                    blockpatches = ubmethods.patchdelin_landscape_patch_delineation(lucdatamatrix,                                                                                    landuseraster.get_nodatavalue())                elif self.geometry_type == "HEXAGONS":                    # Convert all nodatavalue - 9999 in lucadj to nodatavalue                    blockpatches = ubmethods.patchdelin_landscape_patch_delineation(lucadj,                                                                                    landuseraster.get_nodatavalue())                else:                    blockpatches = []                for p in range(len(blockpatches)):      # Scan all patches in the Block, transfer information.                    if blockpatches[p]["Landuse"] == landuseraster.get_nodatavalue():                        continue                    patchxy = (blockpatches[p]["Centroid_xy"][0] * luc_res + current_block.get_attribute("OriginX"),                               blockpatches[p]["Centroid_xy"][1] * luc_res + current_block.get_attribute("OriginY"))                    # Points X and Y are based on the Centroid, calculated                    bID = current_block.get_attribute("BlockID")                    patcharea = blockpatches[p]["PatchSize"] * luc_res * luc_res                    patch_buffer_radius = math.sqrt(patcharea / math.pi)                    patch_attr = ubdata.UBVector([patchxy])                    patch_attr.add_attribute("PatchID", blockpatches[p]["PatchID"])   # PatchID counts from 1 to N                    patch_attr.add_attribute("PatchName", "B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]))                    patch_attr.add_attribute("PatchIndices", blockpatches[p]["PatchIndices"])                    patch_attr.add_attribute("Status", 1)       # Used for exporting and working with patches                    patch_attr.add_attribute("Landuse", blockpatches[p]["Landuse"])                    patch_attr.add_attribute("CentroidX", patchxy[0])                    patch_attr.add_attribute("CentroidY", patchxy[1])                    patch_attr.add_attribute("AspRatio", blockpatches[p]["AspRatio"])                    patch_attr.add_attribute("PatchSize", blockpatches[p]["PatchSize"])                    patch_attr.add_attribute("PatchArea", patcharea)                    patch_attr.add_attribute("BuffRadius", patch_buffer_radius)                    # Save the patch to the scenario as B#_PatchID#                    patch_attr.add_attribute("BlockID", bID)                    self.scenario.add_asset("B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]), patch_attr)                    patchIDs.append("B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]))                current_block.add_attribute("PatchIDs", patchIDs)   # Used later to map other attributes to patches            else:                if self.geometry_type == "VECTORPATCH":     # Do not modify the list if the geometry type is VECTORPATCH                    pass                else:                    current_block.add_attribute("PatchIDs", [])     # If no patches, empty list!            # POPULATION TO BLOCKS            if self.population_map:                self.map_attr.add_attribute("HasPOP", 1)                popdatamatrix, dataXY = self.get_data_matrix_from_input_raster(                    current_block, populationraster, population_offset, pop_res, pop_cscx, pop_cscy)                if self.geometry_type == "SQUARES":                    popfactor, total_population = self.process_population_datamatrix_for_current_block(                        current_block, popdatamatrix, pop_dref, pop_res, populationraster)                elif self.geometry_type == "HEXAGONS":                    hexpoly = [p[:2] for p in current_block.get_points()]                    popadj, cmo = self.create_raster_mask_for_hexagon(                        popdatamatrix, Polygon(hexpoly), dataXY, populationraster.get_cellsize(), 0)                    popfactor, total_population = self.process_population_datamatrix_for_current_block(                        current_block, popadj, pop_dref, pop_res, populationraster)                elif self.geometry_type == "VECTORPATCH":                    patchIDs = current_block.get_attribute("PatchIDs")      # Get all patches for polygons                    total_population = self.map_population_to_patches(patchIDs, popdatamatrix, populationraster.get_nodatavalue(),                                                   pop_dref, populationraster.get_cellsize(), True)                    # Ignoring non-res land uses!                else:                    total_population = 0                map_population += total_population                # Map Population Data to Patches if they exist (applies only to SQUARES and HEXAGONS Geometry Type)                if self.patchdelin and self.landuse_map and self.geometry_type != "VECTORPATCH":                    mapXY = [int(current_block.get_attribute("OriginX") / pop_res) * pop_res,                             int(current_block.get_attribute("OriginY") / pop_res) * pop_res]                    patchIDs = current_block.get_attribute("PatchIDs")                    for p in range(len(patchIDs)):                        # Step 1 - Get the Patch Object                        patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))                        # Step 2 - Extract the data from the map                        if self.geometry_type == "SQUARES":                            popdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, pop_res,                                                                                patch_obj, popdatamatrix)                        elif self.geometry_type == "HEXAGONS":                            popdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, pop_res,                                                                                patch_obj, popadj)                        else:                            popdata = []                        # Step 3 - Summarise the data for the patch and write to attributes                        if len(popdata) == 0:                            patch_obj.add_attribute("Population", 0)                        else:                            popdata[popdata == populationraster.get_nodatavalue()] = 0   # Remove all no-data values                            patch_obj.add_attribute("Population", int(sum(popdata) * popfactor))            # ELEVATION DATA            if self.elevation_map:                self.map_attr.add_attribute("HasELEV", 1)                if current_block.get_attribute("Status") == 0:                    continue    # If block has Status == 0, skip                elevdatamatrix, dataXY = self.get_data_matrix_from_input_raster(                    current_block, elevationraster, elevation_offset, elev_res, elev_cscx, elev_cscy)                if self.geometry_type == "SQUARES":                    self.process_elevation_datamatrix_for_current_block(current_block, elevdatamatrix, elevationraster)                elif self.geometry_type == "HEXAGONS":                    hexpoly = [p[:2] for p in current_block.get_points()]                    elevadj, cmo = self.create_raster_mask_for_hexagon(elevdatamatrix, Polygon(hexpoly), dataXY,                                                                  elevationraster.get_cellsize(),                                                                  elevationraster.get_nodatavalue())                    self.process_elevation_datamatrix_for_current_block(current_block, elevadj, elevationraster)                elif self.geometry_type == "VECTORPATCH":                    patchIDs = current_block.get_attribute("PatchIDs")  # Get all patches for polygons                    self.map_elevation_to_patches(patchIDs, elevdatamatrix, elevationraster.get_nodatavalue())                # Map elevation data onto Block Patches                if self.patchdelin and self.landuse_map and self.geometry_type != "VECTORPATCH":                    if current_block.get_attribute("Status") == 0:                        patchIDs = current_block.get_attribute("PatchIDs")                        if patchIDs is None:                            pass                        else:                            for p in range(len(patchIDs)):   # If the current Block's status is zero, switch all patches                                patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))     # to zero as well.                                patch_obj.change_attribute("Status", 0)                    else:                        mapXY = [int(current_block.get_attribute("OriginX") / elev_res) * elev_res,                                 int(current_block.get_attribute("OriginY") / elev_res) * elev_res]                        patchIDs = current_block.get_attribute("PatchIDs")                        for p in range(len(patchIDs)):                            # Step 1 - Get the Patch Object                            patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))                            # Step 2 - Extract the data from the map                            if self.geometry_type == "SQUARES":                                elevdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, elev_res,                                                                                     patch_obj, elevdatamatrix)                            elif self.geometry_type == "HEXAGONS":                                elevdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, elev_res,                                                                                     patch_obj, elevadj)                            else:                                elevdata = []                            # Step 3 - Summarise the data for the patch and write to attributes                            elevdata_clean = []                            for e in range(len(elevdata)):                                if elevdata[e] == elevationraster.get_nodatavalue():                                    continue                                elevdata_clean.append(elevdata[e])                            try:                                patch_obj.add_attribute("Elevation", float(sum(elevdata_clean)/len(elevdata_clean)))                            except ZeroDivisionError:                                patch_obj.add_attribute("Elevation", current_block.get_attribute("AvgElev"))                                # If no elevation data available, set it to the current Block's elevation data        # - STEP 2.5 - APPLY POPULATION CORRECTION FACTOR        self.notify("Data-read Population Data is: " + str(map_population))        if self.population_corr:            self.notify("Applying population adjustments.")            new_map_population = 0            if self.population_scale_auto:                pop_scalar = total_data_pop / map_population            else:                pop_scalar = self.population_scale            for i in range(len(blockslist)):                if blockslist[i].get_attribute("Status") == 0:                    continue                else:                    adj_pop = int(blockslist[i].get_attribute("Population") * pop_scalar)                    blockslist[i].set_attribute("Population", adj_pop)                    new_map_population += adj_pop            self.notify("Adjusted Population Data is: " + str(new_map_population))        # - STEP 3 - FIND BLOCK NEIGHBOURHOOD        self.notify("Establishing neighbourhoods")        for i in range(len(blockslist)):  # Loop across current Blocks            curblock = blockslist[i]    # curblock is the reference to the UBVector() instance in blockslist            if curblock.get_attribute("Status") == 0:                continue    # If the block has zero status, don't consider            curblock_id = curblock.get_attribute("BlockID")            # print("Working out neighbourhoods for BlockID", str(curblock_id))            if nhd_type == "M":         # SQUARES                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "points", "all")            elif nhd_type in ["V", "ISO"]:       # VON-NEUMANN and HEXAGON ISOTROPIC                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "edges", "all")            elif nhd_type == "DIRICHLET":   # VECTORPATCHES                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "points", "all")  # GET MOORE            elif nhd_type == "YINV":    # ADVANCED/EXPERIMENTAL: Inverse-Y neighbourhood HEXAGONS                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "edges", [1, 3, 5])            elif nhd_type == "YNOR":    # ADVANCED/EXPERIMENTAL: Y-neighbourhood HEXAGONS                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "edges", [0, 2, 4])            elif nhd_type == "NOR":     # ADVANCED/EXPERIMENTAL: Non-orthogonal Neighbourhood HEXAGONS                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "edges", [1, 2, 4, 5])            else:                nhd = self.find_block_neighbours_by_geometry(curblock, blockslist, "edges", "all")            curblock.add_attribute("Neighbours", nhd)  # ATTRIBUTE: neighbourhood type<list> - [ Block IDs ]            if self.geometry_type == "VECTORPATCH":     # BASED ON THE MOORE NEIGHBOURHOOD                self.notify("Establishing Dirichlet Neighbourhood...")                self.find_dirichlet_neighbourhood(curblock, nhd)        # - STEP 4 - Assign Municipal Regions and Suburban Regions to Blocks        municipalities = []        if self.include_geopolitical:                       # LOAD MUNICIPALITY MAP            self.notify("Loading Municipality Map")            self.map_attr.add_attribute("HasGEOPOLITICAL", 1)            geopol_map = self.datalibrary.get_data_with_id(self.geopolitical_map)            fullfilepath = geopol_map.get_data_file_path() + geopol_map.get_metadata("filename")            municipalities = ubspatial.import_polygonal_map(fullfilepath, "native", "Municipality",                                                            (self.map_attr.get_attribute("xllcorner"),                                                             self.map_attr.get_attribute("yllcorner")))            for i in range(len(municipalities)):                self.scenario.add_asset(municipalities[i].get_attribute("Map_Naming"), municipalities[i])        else:            self.map_attr.add_attribute("HasGEOPOLITICAL", 0)        suburbs = []        if self.include_suburb:                             # LOAD SUBURBAN MAP            self.notify("Loading Suburb Map")            self.map_attr.add_attribute("HasSUBURBS", 1)            suburb_map = self.datalibrary.get_data_with_id(self.suburban_map)            fullfilepath = suburb_map.get_data_file_path() + suburb_map.get_metadata("filename")            suburbs = ubspatial.import_polygonal_map(fullfilepath, "native", "Suburb",                                                     (self.map_attr.get_attribute("xllcorner"),                                                      self.map_attr.get_attribute("yllcorner")))            for i in range(len(suburbs)):                self.scenario.add_asset(suburbs[i].get_attribute("Map_Naming"), suburbs[i])        else:            self.map_attr.add_attribute("HasSUBURBS", 0)        planzones = []        if self.include_planzone:  # LOAD SUBURBAN MAP            self.notify("Loading Planning Zones Map")            self.map_attr.add_attribute("HasPLANZONES", 1)            planzone_map = self.datalibrary.get_data_with_id(self.planzone_map)            fullfilepath = planzone_map.get_data_file_path() + planzone_map.get_metadata("filename")            planzones = ubspatial.import_polygonal_map(fullfilepath, "native", "Planning Zones",                                                     (self.map_attr.get_attribute("xllcorner"),                                                      self.map_attr.get_attribute("yllcorner")))            for i in range(len(suburbs)):                self.scenario.add_asset(planzones[i].get_attribute("Map_Naming"), planzones[i])        else:            self.map_attr.add_attribute("HasPLANZONES", 0)        # Check intersection with blocks - assign the municipality, suburb and planning zones based on Block Centroid        if self.geometry_type in ["SQUARES", "HEXAGONS"]:            scanlist = blockslist        else:            patchlist = self.get_complete_patch_list(blockslist)            scanlist = patchlist        for i in range(len(scanlist)):            cur_asset = scanlist[i]            coordinates = cur_asset.get_points()            # List comprehension: creates a list of coordinates with only            # x, y points. I.e. removes the Z-coordinate            coordinates = [c[:2] for c in coordinates]            assetpoly = Polygon(coordinates)            # Keep searching (search = 1), block Centroid within municipality and suburb? Until found (search = 0)            intersectarea = 0            intersectname = ""            for m in municipalities:                featpoly = Polygon(m.get_points())                if not featpoly.intersects(assetpoly):  # If there is no intersection...                    continue                newisectionarea = featpoly.intersection(assetpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.geopolitical_attref)            if intersectname != "" and intersectarea > 0:                cur_asset.add_attribute("Region", intersectname)            else:                cur_asset.add_attribute("Region", "Unassigned")            intersectarea = 0            intersectname = ""            for m in suburbs:                featpoly = Polygon(m.get_points())                if not assetpoly.intersects(featpoly):                    continue                newisectionarea = assetpoly.intersection(featpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.suburban_attref)            if intersectname != "" and intersectarea > 0:                cur_asset.add_attribute("Suburb", intersectname)            else:                cur_asset.add_attribute("Suburb", "Unassigned")            intersectarea = 0            intersectname = ""            for m in planzones:                featpoly = Polygon(m.get_points())                if not assetpoly.intersects(featpoly):                    continue                newisectionarea = assetpoly.intersection(featpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.planzone_attref)            if intersectname != "" and intersectarea > 0:                cur_asset.add_attribute("PlanZone", intersectname)            else:                cur_asset.add_attribute("PlanZone", "Unassigned")        # - STEP 5 - Load Rivers, Lakes and built infrastructure, assign to Blocks and calculate closest distance        # STEP 5.1 :: Grab maps and assign their data to Blocks        if self.include_rivers:            self.map_attr.add_attribute("HasRIVERS", 1)            river_map = self.datalibrary.get_data_with_id(self.river_map)            self.notify("Loading River Map")            fullfilepath = river_map.get_data_file_path() + river_map.get_metadata("filename")            rivers = ubspatial.import_linear_network(fullfilepath, "LINES",                                                     (self.map_attr.get_attribute("xllcorner"),                                                      self.map_attr.get_attribute("yllcorner")))            if self.geometry_type in ["SQUARES", "HEXAGONS"]:                self.detect_rivers_in_assets(blockslist, rivers)            elif self.geometry_type == "VECTORPATCH":                self.detect_rivers_in_assets(patchlist, rivers)        else:            self.map_attr.add_attribute("HasRIVERS", 0)        if self.include_lakes:            self.map_attr.add_attribute("HasLAKES", 1)            lake_map = self.datalibrary.get_data_with_id(self.lake_map)            self.notify("Loading Lakes Map")            fullfilepath = lake_map.get_data_file_path() + lake_map.get_metadata("filename")            lakes = ubspatial.import_polygonal_map(fullfilepath, "native", "Lake",                                                   (self.map_attr.get_attribute("xllcorner"),                                                    self.map_attr.get_attribute("yllcorner")))            if self.geometry_type in ["SQUARES", "HEXAGONS"]:                self.detect_lakes_in_assets(blockslist, lakes)            elif self.geometry_type == "VECTORPATCH":                self.detect_lakes_in_assets(patchlist, lakes)        else:            self.map_attr.add_attribute("HasLAKES", 0)        # STEP 5.2 :: Calculate distance to closest water body if the user wants        if self.calculate_wbdistance:            if self.geometry_type in ["SQUARES", "HEXAGONS"]:                self.calculate_closest_waterbody(blockslist)            elif self.geometry_type == "VECTORPATCH":                self.calculate_closest_waterbody(patchlist)        # STEP 5.3 :: Load other built infrastructure data        if self.include_storm:      # Their sole purpose is to support the delineation of stormwater flow paths            self.map_attr.add_attribute("HasSTORMDRAINS", 1)            storm_map = self.datalibrary.get_data_with_id(self.storm_map)            self.notify("Loading Storm Drains")            fullfilepath = storm_map.get_data_file_path() + storm_map.get_metadata("filename")            stormdrains = ubspatial.import_linear_network(fullfilepath, "LINES",                                                          (self.map_attr.get_attribute("xllcorner"),                                                           self.map_attr.get_attribute("yllcorner")))            if self.geometry_type in ["SQUARES", "HEXAGONS"]:                self.detect_stormdrains_in_assets(blockslist, stormdrains)            elif self.geometry_type == "VECTORPATCH":                self.detect_stormdrains_in_assets(patchlist, stormdrains)        else:            self.map_attr.add_attribute("HasSTORMDRAINS", 0)        # - STEP 6 - Calculate topography (slope/aspect), delineate Flow Paths and Drainage Basins        # STEP 6.1 :: Calculate slope and aspect        if self.map_attr.get_attribute("HasELEV") and self.geometry_type == "SQUARES":            # Calculate slope and aspect            self.notify("Calculating slope and aspect for each Block")            print("Calculating slope and aspect for each Block")            if self.dem_smooth:     # If the user wishes to smooth the DEM, then perform the smoothing passes                self.perform_smooth_dem(blockslist)            self.calculate_slope_aspect_for_blocks(blockslist, elevationraster.get_nodatavalue())        if self.map_attr.get_attribute("HasELEV") and self.flowpaths:            # Delineate flow paths            self.notify("Delineating flow paths and drainage sub-basins")            if self.geometry_type in ["SQUARES", "HEXAGONS"]:                self.delineate_flow_paths(blockslist)     # Delineates the flow directions                totalbasins = self.delineate_basin_structures(blockslist)   # Delineates the sub-catchments            elif self.geometry_type == "VECTORPATCH":                self.delineate_dirichlet_flow_paths(patchlist)            # Write details to map attributes            # self.map_attr.add_attribute("TotalBasins", totalbasins)            self.map_attr.add_attribute("HasFLOWPATHS", 1)        else:            self.map_attr.add_attribute("HasFLOWPATHS", 0)        # - STEP 7 Delineate Patch Flow Paths - ADVANCED/EXPERIMENTAL        if self.patchdelin and self.patchflowpaths and \                self.elevation_map and self.landuse_map and self.geometry_type in ["SQUARES", "HEXAGONS"]:            self.notify("Delineating flow paths among patches")            print("Delineating flow paths among patches")            self.delineate_patch_flow_paths()            self.map_attr.add_attribute("HasPATCHFLOW", 1)        else:            self.map_attr.add_attribute("HasPATCHFLOW", 0)        # - STEP 8 - Spatial Connectivity - DIRICHLET NETWORK        if self.geometry_type == "VECTORPATCH":            self.notify("Constructing Dirichlet Network")            self.construct_dirichlet_network()            self.map_attr.add_attribute("HasDIRICHLET_NET", 1)        else:            self.map_attr.add_attribute("HasDIRICHLET_NET", 0)        # - STEP 9 - Parks Connectivity - ADVANCED/EXPERIMENTAL        print("DELINBLOCKS: Patchdelin", self.patchdelin)        if self.patchdelin and self.geometry_type in ["SQUARES", "HEXAGONS"]:            green_patches, grey_patches, non_patches = self.retrieve_patch_groups()            if len(green_patches) > 0:                # 7.1 - Open Space Distances                if self.osnet_accessibility:                    self.notify("Analysing open space accessibility")                    print("Analysing open space accessibility")                    self.find_open_space_distances(green_patches, grey_patches, non_patches)                    self.map_attr.add_attribute("HasOSLINK", 1)                else:                    self.map_attr.add_attribute("HasOSLINK", 0)                # 7.2 - Open Space Network                if self.osnet_network:                    self.notify("Analysing open space network")                    print("Analysing open space network")                    # The minimum acceptable distance to connect the network is taken as the final block size, if two                    # entire Block patches exist, they are adjacent and connected by Block centroid                    min_dist = self.final_bs*math.sqrt(2)                    self.delineate_open_space_network(green_patches, grey_patches, non_patches, min_dist)                    self.map_attr.add_attribute("HasOSNET", 1)                else:                    self.map_attr.add_attribute("HasOSNET", 0)            else:                self.notify("Warning, no open spaces in map, cannot check for links")                self.map_attr.add_attribute("HasOSLINK", 0)                self.map_attr.add_attribute("HasOSNET", 0)        # - CLEAN-UP - RESET ALL VARIABLES FOR GARBAGE COLLECTOR        self.notify("End of Delinblocks")        print("End of Delinblocks")        return False    # ------------------------------------------------    # |-    ADDITIONAL MODULE FUNCTIONS             -|    # ------------------------------------------------    def find_block_neighbours_by_geometry(self, curblock, blockslist, criterion, selection):        """ Performs the neighbourhood scan based on shared edges or points."""        nhd = []        for i in range(len(blockslist)):            comp_block_id = blockslist[i].get_attribute("BlockID")            curblock_id = curblock.get_attribute("BlockID")            if curblock_id == comp_block_id or blockslist[i].get_attribute("Status") == 0:                # The IDs are identical or the block has zero status, skip                continue            if comp_block_id == 66 and curblock_id == 65:                print ("Located Block IDs 65 and 66")                print(curblock.get_edges(), blockslist[i].get_edges())            if curblock.shares_geometry(blockslist[i], criterion, selection):                nhd.append(comp_block_id)        return nhd    def import_data_for_input_raster_map(self, dataset):        """ Returns a UBRaster and relevant metadata for an input data reference dataset.        :param dataset: the input ID of the data set as saved in the UB Data Library        :return: UBRaster object, offsets, resolution and cells wide/tall factors        """        dref = self.datalibrary.get_data_with_id(dataset)        fullfilpath = dref.get_data_file_path() + dref.get_metadata("filename")        self.notify("Loading: " + str(fullfilpath))        raster = ubspatial.import_ascii_raster(fullfilpath, dataset)        self.notify("Load Complete!")        raster_offset = ubspatial.calculate_offsets(raster, self.map_attr)        map_res = raster.get_cellsize()        if self.geometry_type in ["SQUARES", "VECTORPATCH"]:            cscx = int(math.ceil(self.final_bs / map_res))            cscy = cscx        elif self.geometry_type == "HEXAGONS" and self.hex_orientation == "NS":            cscx = int(math.ceil(self.final_bs * 2 / map_res))            cscy = int(math.ceil(self.final_bs * math.sqrt(3)) / map_res)        elif self.geometry_type == "HEXAGONS" and self.hex_orientation == "EW":            cscx = int(math.ceil(self.final_bs * math.sqrt(3) / map_res))            cscy = int(math.ceil(self.final_bs * 2 / map_res))        else:            cscx = None     # Cells per block doesn't apply in other cases            cscy = None        # csc = cell selection count - knowing how many cells wide and tall        return dref, raster, raster_offset, map_res, cscx, cscy    def create_raster_mask_for_hexagon(self, inputraster, hexpoly, ref_coords, res, nodatavalue):        """ Creates a mask array for the current input        :param inputraster:        :param hexpoly:        :param ref_coords:        :return:        """        # --- NEW MASKING ALGORITHM BASED ON VECTOR PATCHES [TO DO]        # --- ISSUE: The hexagon is not aligned with the grid, the inputraster is at 0,0 coordinate system, the bounding        #           box around the hexagon. Need to readjust the polygon of the hexagon to the 0,0 origin to fit the        #           box of the inputraster grid. This also has to account for potential offsets for added accuracy!        # print(inputraster)        # geom = shapely.geometry.mapping(hexpoly)        # print(geom)        # mask = features.rasterize([geom], out_shape=inputraster.shape)        # datamask = np.ma.masked_array(inputraster, mask=1-mask)        # print(datamask)        cells_masked_out = 0        mask_array = np.ones(inputraster.shape)     # Make an identical array of ones to that of inputraster        for i in range(len(inputraster)):            for j in range(len(inputraster[0])):                x = ref_coords[0] + j * res                y = ref_coords[1] + i * res                if Point(x, y).within(hexpoly):                    mask_array[i, j] = inputraster[i, j]                else:                    mask_array[i, j] = nodatavalue       # Make this significantly different from nodatavalue                    cells_masked_out += 1        return mask_array, cells_masked_out    def get_data_matrix_from_input_raster(self, block, raster, offset, res, cscx, cscy):        """ Scans the input raster based on the current Block's corner coordinates (OriginXY) and returns a matrix        of numbers, which is a subset of the input raster.        :param block: the current UBVector Block Object        :param raster: the loaded input raster map as UBRaster        :param offset: offsets [x, y] of the raster map        :param res: resolution of the raster map [m]        :param csc: cells wide/tall, proportion of raster map and block size        :return: datamatrix a square matrix containing raster data for the covered extents, returns the origin of data        """        col_origin = int(block.get_attribute("OriginX") / res)        col_start_adj, cscx = ubspatial.adjust_position_by_offset(col_origin, offset[0], cscx)        row_origin = int(block.get_attribute("OriginY") / res)        row_start_adj, cscy = ubspatial.adjust_position_by_offset(row_origin, offset[1], cscy)        datamatrix = raster.get_data_square(col_start_adj, row_start_adj, cscx, cscy)        return datamatrix, [col_start_adj * res, row_start_adj * res]    def process_elevation_datamatrix_for_current_block(self, block, datamatrix, raster):        """ Analyses the elevation data matrix for the current block and writes the average, max and min elevation to        its attributes list.        :param block: Current Block UBVector()        :param datamatrix: the elevation data matrix for the current Block's bounds        :param raster: The original elevation raster UBRaster() object        :return: True, attributes written to attribute list of current block.        """        elev_values = datamatrix.flatten()        elev_values = list(filter(lambda a: a != raster.get_nodatavalue(), elev_values))  # Remove all no-data values        if len(elev_values) == 0:            block.set_attribute("Status", 0)        else:            block.set_attribute("Status", 1)            block.add_attribute("AvgElev", sum(elev_values) / max(float(len(elev_values)), 1.0))            block.add_attribute("MaxElev", max(elev_values))            block.add_attribute("MinElev", min(elev_values))        return True    def process_population_datamatrix_for_current_block(self, block, datamatrix, dref, res, raster):        """ Analyses the population data matrix for the current block and writes the total population to its attributes        list.        :param block: the current UBVector() Block object        :param datamatrix: the population data matrix for the current Block's bounds        :param dref: the data reference object for the population data        :param res: the resolution of the population raster        :param raster: the UBRaster() object of the population data        :return: popfactor [dependent on density or total], total population        """        popfactor = 1.0        if dref.get_metadata("sub") == "Density":            popfactor = (float(res) * float(res)) / 10000.0  # Area of a single cell (persons/ha)        elif dref.get_metadata("sub") == "Count":            popfactor = 1.0  # No multiplication        pop_values = datamatrix.flatten()  # Flatten to a single array        pop_values[pop_values == raster.get_nodatavalue()] = 0  # Remove all no-data values        total_population = float(sum(pop_values) * popfactor)        block.add_attribute("Population", int(total_population))        return popfactor, total_population    def create_vector_patches(self, current_block, patchIDtrack, lucdatamatrix, cs, ndv):        """ Takes the current LUC data matrix and delineates all relevant patches for the corresponding Block.        :param current_block: the current Block UBVector        :param patchIDtrack: the integer number to begin counting from based on patch labels        :param lucdatamatrix: the numpy array containing the land use data based on which patches are delineated        :param cs: cell size of the landuse raster        :param ndv: the nodata value so the model knows how to skip the value        :return:        """        if lucdatamatrix.sum() == 0:    # If there is no data for this part of the map, return an empty list.            return [], [], patchIDtrack        offsetXY = [current_block.get_attribute("OriginX"), current_block.get_attribute("OriginY")]        patchIDlist = []    # Contains all the patch IDs for the current block        patch_assets = []        pg = features.shapes(lucdatamatrix)        for shape, value in pg:            if value == ndv:                continue    # Skip if the current patch has no-data            patchIDtrack += 1    # We have a patch, increment the ID by 1            patchIDlist.append(patchIDtrack)            # Get Patch Geometry, scale to cell size and get correct offset            pts = shape['coordinates'][0]   # Get the current coordinates (assuming always a polygon)            pts = [(pts[i][0]*float(cs) + offsetXY[0], pts[i][1]*float(cs)+offsetXY[1]) for i in range(len(pts))]            poly = Polygon(pts)            edge_list = [(pts[i], pts[i+1]) for i in range(len(pts)-1)]            # Create the UBVector and fill with attributes            patch_attr = ubdata.UBVector(pts, edge_list)            patch_attr.add_attribute("Rasterio_Shape", shape)            patch_attr.add_attribute("PatchID", int(patchIDtrack))              # ID            patch_attr.add_attribute("Area", float(poly.area))                  # Geometry            patch_attr.add_attribute("CentreX", float(poly.centroid.x))            patch_attr.add_attribute("CentreY", float(poly.centroid.y))            patch_attr.add_attribute("RepX", float(poly.representative_point().x))            patch_attr.add_attribute("RepY", float(poly.representative_point().y))            patch_attr.add_attribute("BlockID", current_block.get_attribute("BlockID"))     # Block details            patch_attr.add_attribute("OriginX", current_block.get_attribute("OriginX"))            patch_attr.add_attribute("OriginY", current_block.get_attribute("OriginY"))            patch_attr.add_attribute("LandUse", ubglobals.LANDUSENAMES[int(value)-1])       # Land use            patch_attr.add_attribute("Status", 1)  # Tracks data completeness based on elevation and land use            patch_assets.append(patch_attr)     # Add the asset to the list        return patch_assets, patchIDlist, patchIDtrack    def get_complete_patch_list(self, blockslist):        """ Gets a complete list of patch UBVector Objects"""        patchlist = []        for i in range(len(blockslist)):            patchIDs = blockslist[i].get_attribute("PatchIDs")            for j in range(len(patchIDs)):                patchlist.append(self.scenario.get_asset_with_name("PatchID"+str(patchIDs[j])))        return patchlist    def map_datamatrix_to_current_patches(self, patchIDs, datamatrix, nodatavalue):        """ Based on a datamatrix numpy array and a list of patchIDs, this function retrieves the datapoints in the        matrix for each patch and provides lists for each patch.        :param patchIDs: list of PatchIDs, retrieved for the current Block.        :param datamatrix: the numpy array data matrix        :return: [ datapoints as lists() ], these can be processed later on using stats.        """        patchIDs_data = []        nodatamatrix_check = datamatrix.sum()        for i in range(len(patchIDs)):            if nodatamatrix_check == 0:     # If there is no datamatrix becaus the dimensions are empty                datalist = [nodatavalue]    # then simply pass nodatavalue                patchIDs_data.append(datalist)                continue            curpatch = self.scenario.get_asset_with_name("PatchID"+str(int(patchIDs[i])))            geom = curpatch.get_attribute("Rasterio_Shape")     # The original rasterio polygon            mask = features.rasterize([geom], out_shape=datamatrix.shape)            datamask = np.ma.masked_array(datamatrix, mask=1-mask)            datalist = datamask.compressed()            patchIDs_data.append(datalist)        return patchIDs_data    def map_population_to_patches(self, patchIDs, datamatrix, nodatavalue, dref, res, ignore_nonres):        """ Maps all population data to the patches based on location and mask, calculates total Population for the        patch in question (note this is very sensitive to how the spatial data is aligned!        """        popfactor = 1.0        if dref.get_metadata("sub") == "Density":            popfactor = (float(res) * float(res)) / 10000.0  # Area of a single cell (persons/ha)        elif dref.get_metadata("sub") == "Count":            popfactor = 1.0  # No multiplication        patchIDs_data = self.map_datamatrix_to_current_patches(patchIDs, datamatrix, nodatavalue)        total_pop = 0        for i in range(len(patchIDs)):            curpatch = self.scenario.get_asset_with_name("PatchID"+str(int(patchIDs[i])))            # if ignore_nonres and curpatch.get_attribute("LandUse") != "Residential":            #     curpatch.add_attribute("Population", 0)            #     continue    # If the factor ignore-nonres is True, will skip patches with no residential            datalist = patchIDs_data[i]            datalist = [0 if x == nodatavalue else x * popfactor for x in datalist]     # Remove no-data and scale            curpatch.add_attribute("Population", sum(datalist))            total_pop += sum(datalist)        return total_pop    def map_elevation_to_patches(self, patchIDs, datamatrix, nodatavalue):        patchIDs_data = self.map_datamatrix_to_current_patches(patchIDs, datamatrix, nodatavalue)        for i in range(len(patchIDs)):            curpatch = self.scenario.get_asset_with_name("PatchID"+str(int(patchIDs[i])))            datalist = patchIDs_data[i]            datalist = list(filter(lambda a: a!= nodatavalue, datalist))    # Remove nodatavalues            if len(datalist) == 0:          # If there is no elevation data, remove the patch from the simulation                curpatch.add_attribute("AvgElev", None)                curpatch.add_attribute("MinElev", None)                curpatch.add_attribute("MaxElev", None)                curpatch.set_attribute("Status", 0)            else:                curpatch.add_attribute("AvgElev", sum(datalist) / float(len(datalist)))                curpatch.add_attribute("MinElev", min(datalist))                curpatch.add_attribute("MaxElev", max(datalist))        return True    def find_dirichlet_neighbourhood(self, curblock, nhd):        """Finds the Dirichlet Neighbourhood for the current Block's patches based on its Moore neighbourhood.        :param curblock: the current Block UBVector() object        :param nhd: the Moore neighbourhood of the current Block        :return: writes the PatchIDs to the Dirichlet neighbourhood        """        patchIDs = curblock.get_attribute("PatchIDs")   # List of current patches to search for neighbours        nhd_patchIDs = [i for i in patchIDs]    # List of all candidate patches from the grid's Moore neighbourhood        for i in range(len(nhd)):            neigh_block = self.scenario.get_asset_with_name("BlockID"+str(nhd[i]))            neigh_patches = neigh_block.get_attribute("PatchIDs")            for j in neigh_patches:                nhd_patchIDs.append(j)      # Add the neighbouring patches to the candidate patches        # Scan patch neighbourhoods based on Shapely intersection.        for p in range(len(patchIDs)):            nhd = []            edge_data = []            curpatch = self.scenario.get_asset_with_name("PatchID"+str(patchIDs[p]))            if curpatch.get_attribute("Status") == 0:                continue    # Skip if status is zero            for n in range(len(nhd_patchIDs)):                if patchIDs[p] == nhd_patchIDs[n]:                    continue    # Same Patch!                candidate = self.scenario.get_asset_with_name("PatchID"+str(nhd_patchIDs[n]))                if candidate.get_attribute("Status") == 0:                    continue    # Skip if status is zero                shared_edge = Polygon(curpatch.get_points()).intersection(Polygon(candidate.get_points())).length                if shared_edge != 0:                    nhd.append(nhd_patchIDs[n])     # If there is an intersection, patch is a neighbour                    edge_data.append((nhd_patchIDs[n], shared_edge))            # Consolidate neighbourhood data            curpatch.add_attribute("Neighbours", nhd)            curpatch.add_attribute("EdgeData", edge_data)       # [ (ID, edgelength), ... ]            # print("Neighbours for PatchID"+str(patchIDs[p]), nhd)        return True    def construct_dirichlet_network(self):        patches = self.scenario.get_assets_with_identifier("PatchID")        nodes = {"ID":[], "x":[], "y":[]}        links = {"ID":[], "Nodes":[], "Dist":[], "Edge":[]}        linkIDcount = 1        for i in range(len(patches)):            curpatch = patches[i]            if curpatch.get_attribute("Status") == 0:                continue            curpatchID = curpatch.get_attribute("PatchID")            nhd_data = curpatch.get_attribute("EdgeData")            # Create the Node            if curpatchID not in nodes["ID"]:                nodes["ID"].append(curpatchID)                nodes["x"].append(curpatch.get_attribute("RepX"))                nodes["y"].append(curpatch.get_attribute("RepY"))            # Create Links            for j in range(len(nhd_data)):                linkID = nhd_data[j][0]                link_edge = nhd_data[j][1]                link_asset = self.scenario.get_asset_with_name("PatchID"+str(linkID))                if link_asset.get_attribute("Status") == 0:                    continue                link = [curpatchID, linkID]                link.sort()                if link in links["Nodes"]:                    continue                dx = curpatch.get_attribute("CentreX") - link_asset.get_attribute("CentreX")                dy = curpatch.get_attribute("CentreY") - link_asset.get_attribute("CentreY")                dist = math.sqrt((dx * dx) + (dy * dy))     # Euclidean distance                links["ID"].append(linkIDcount)                links["Nodes"].append(link)                links["Dist"].append(dist)                links["Edge"].append(link_edge)                # Draw the network link                up_point = (curpatch.get_attribute("RepX"), curpatch.get_attribute("RepY"),                            curpatch.get_attribute("AvgElev"))                down_point = (link_asset.get_attribute("RepX"), link_asset.get_attribute("RepY"),                              link_asset.get_attribute("AvgElev"))                network_link = ubdata.UBVector((up_point, down_point))                network_link.determine_geometry((up_point, down_point))                network_link.add_attribute("LinkID", linkIDcount)                network_link.add_attribute("NodeA", link[0])                network_link.add_attribute("NodeB", link[1])                network_link.add_attribute("Distance", dist)                network_link.add_attribute("EdgeWidth", link_edge)                network_link.add_attribute("Traversal", float(dist/link_edge))  # Ease of traversal                self.scenario.add_asset("LinkID"+str(linkIDcount), network_link)                linkIDcount += 1    def delineate_dirichlet_flow_paths(self, patchlist):        """        :param patchlist:        :return:        """        sink_ids = []        river_ids = []        lake_ids = []        for i in range(len(patchlist)):            curpatch = patchlist[i]            curpatchID = curpatch.get_attribute("PatchID")            # SKIP CONDITION 1 - PATCH HAS ZERO STATUS            if curpatch.get_attribute("Status") == 0:                continue            # SKIP CONDITION 2 - PATCH CONTAINS A RIVER            if curpatch.get_attribute("HasRiver") and not self.ignore_rivers:                curpatch.add_attribute("downID", -2)                curpatch.add_attribute("max_dz", 0)                curpatch.add_attribute("avg_slope", 0)                curpatch.add_attribute("h_pond", 0)                river_ids.append(curpatchID)                continue            # SKIP CONDITION 3 - PATCH CONTAINS A LAKE            if curpatch.get_attribute("HasLake") and not self.ignore_lakes:                curpatch.add_attribute("downID", -2)                curpatch.add_attribute("max_dz", 0)                curpatch.add_attribute("avg_slope", 0)                curpatch.add_attribute("h_pond", 0)                lake_ids.append(curpatchID)            z = curpatch.get_attribute("AvgElev")            # Get neighbouring elevations            if self.guide_natural or self.guide_built:                nhd_z = self.get_modified_neighbours_z(curpatch, "PatchID")                if nhd_z is None:                    nhd_z = self.scenario.retrieve_attribute_value_list("Patch", "AvgElev",                                                                        curpatch.get_attribute("Neighbours"))            else:                nhd_z = self.scenario.retrieve_attribute_value_list("Patch", "AvgElev",                                                                        curpatch.get_attribute("Neighbours"))            # Find the downstream patch unless it's a sink            flow_id, max_zdrop = self.find_downstream_d8(z, nhd_z)            if flow_id == -9999:                sink_ids.append(curpatchID)                downstream_id = -1            else:                downstream_id = flow_id            # Grab distances / slope between the two patches            if flow_id == -9999:                avg_slope = 0            else:                down_patch = self.scenario.get_asset_with_name("PatchID"+str(downstream_id))                dx = curpatch.get_attribute("CentreX") - down_patch.get_attribute("CentreX")                dy = curpatch.get_attribute("CentreY") - down_patch.get_attribute("CentreY")                dist = float(math.sqrt((dx * dx) + (dy * dy)))                avg_slope = max_zdrop / dist            # Add attributes            curpatch.add_attribute("downID", downstream_id)            curpatch.add_attribute("max_dz", max_zdrop)            curpatch.add_attribute("avg_slope", avg_slope)            curpatch.add_attribute("h_pond", 0)            # Create Network Links            if downstream_id != -1 and downstream_id != 0:                network_link = self.draw_flow_path(curpatch, 1, "PatchID", "Rep")                self.scenario.add_asset("FlowID"+str(curpatchID), network_link)        # Unblock the Sinks        self.unblock_sinks(sink_ids, "PatchID", "Rep")        if self.map_attr.get_attribute("HasRIVER"):            self.connect_river_assets(river_ids)        # [TO DO]        return True    def process_landuse_datamatrix_for_current_block(self, current_block, lucdatamatrix, nodatavalue, mask_count):        """ Processes the land use data matrix for the current block, analyses and totals frequencies and calculates        spatial indices if the user enabled it.        :param current_block: the current UBVector() object for the block        :param lucdatamatrix: the datamatrix of land use corresponding to the current Block.        :return:        """        # STEP 1 - FREQUENCY OF LAND USES - TALLY UP        landclassprop, activity = ubmethods.calculate_frequency_of_lu_classes(lucdatamatrix, nodatavalue, mask_count)        if activity == 0:            blockstatus = 0        else:            blockstatus = 1        current_block.set_attribute("Status", blockstatus)        current_block.add_attribute("Active", activity)        # Land use proportions in block (multiply with block area to get Area        current_block.add_attribute("pLU_RES", landclassprop[0])  # RES = Residential        current_block.add_attribute("pLU_COM", landclassprop[1])  # COM = Commercial        current_block.add_attribute("pLU_ORC", landclassprop[2])  # ORC = Mixed Office/Res Development        current_block.add_attribute("pLU_LI", landclassprop[3])  # LI = Light Industry        current_block.add_attribute("pLU_HI", landclassprop[4])  # HI = Heavy Industry        current_block.add_attribute("pLU_CIV", landclassprop[5])  # CIV = Civic        current_block.add_attribute("pLU_SVU", landclassprop[6])  # SVU = Service & Utility Land        current_block.add_attribute("pLU_RD", landclassprop[7])  # RD = Road        current_block.add_attribute("pLU_TR", landclassprop[8])  # TR = Transport Facility        current_block.add_attribute("pLU_PG", landclassprop[9])  # PG = Parks & Garden        current_block.add_attribute("pLU_REF", landclassprop[10])  # REF = Reserves & Floodways        current_block.add_attribute("pLU_UND", landclassprop[11])  # UND = Undeveloped        current_block.add_attribute("pLU_NA", landclassprop[12])  # NA = Unclassified        current_block.add_attribute("pLU_WAT", landclassprop[13])  # WAT = Water        current_block.add_attribute("pLU_FOR", landclassprop[14])  # FOR = Forest        current_block.add_attribute("pLU_AGR", landclassprop[15])  # AGR = Agriculture        # STEP 2 - CALCULATE SPATIAL METRICS (IF THE USER WISHES)        if self.spatialmetrics and blockstatus:            richness = ubmethods.calculate_metric_richness(landclassprop)            shdiv, shdom, sheven = ubmethods.calculate_metric_shannon(landclassprop, richness)            current_block.add_attribute("Rich", richness)            current_block.add_attribute("ShDiv", shdiv)            current_block.add_attribute("ShDom", shdom)            current_block.add_attribute("ShEven", sheven)            self.map_attr.add_attribute("HasSPATIALMETRICS", 1)        return True    def calculate_slope_aspect_for_blocks(self, blocklist, nodata):        """Calculates the slope and aspect attributes for each Block in the map. Saves three attributes to each Block,        Slope in %, Slope in Degrees, Aspect in degrees on compass rose from North.        :param blocklist: the list of UrbanBEATS Block UBVector() instances.        :param nodata: the no-data value of the original data set, so that the model knows how to navigate missing vals.        :return: Writes three attributes to each Block.        """        bs = self.map_attr.get_attribute("BlockSize")        for i in range(len(blocklist)):            if blocklist[i].get_attribute("Status") == 0:                continue            curblock = blocklist[i]            z_central = curblock.get_attribute("AvgElev")            nhd = curblock.get_attribute("Neighbours")            z_nhd = [nodata, nodata, nodata, nodata, nodata, nodata, nodata, nodata]    #[N, NE, E, SE, S, SW, W, NW]            for j in nhd:                n_block = self.scenario.get_asset_with_name("BlockID"+str(j))                # Figure out cardinal direction                if curblock.get_attribute("CentreX") > n_block.get_attribute("CentreX"):                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> SW                        d_index = 5     # South-West                    elif curblock.get_attribute("CentreY") == n_block.get_attribute("CentreY"):     # --> W                        d_index = 6     # West                    else:                        d_index = 7     # North-West because Centre Y of centre is less                elif curblock.get_attribute("CentreX") == n_block.get_attribute("CentreX"):                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> S                        d_index = 4     # South                    elif curblock.get_attribute("CentreY") < n_block.get_attribute("CentreY"):      # --> N                        d_index = 0     # North                    else:                        d_index = 0                        print("SOMETHING IS WRONG - SLOPE ASPECT CALCULATIONS!!")        # n_block == curblock                else:   # curblock Centre X < n_block Centre X                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> SE                        d_index = 3     # South-East                    elif curblock.get_attribute("CentreY") < n_block.get_attribute("CentreY"):  # --> NE                        d_index = 1     # North-East                    else:   #  --> E                        d_index = 2     # East                z_nhd[d_index] = n_block.get_attribute("AvgElev")            # Calculate Slope and Aspect            slope_rad, slope_deg = ubmethods.calculate_slope(z_central, z_nhd, bs, bs, nodata)            curblock.add_attribute("Slope_PCT", round(slope_rad * 100, 2))            curblock.add_attribute("Slope_DEG", round(slope_deg, 2))            aspect_deg = ubmethods.calculate_aspect(z_central, z_nhd, nodata)            curblock.add_attribute("Aspect_DEG", aspect_deg)        return True    def delineate_patch_flow_paths(self):        """Delineates the flowpaths for the patches based on the selected method. Function creates links in UBVector()        format and saves them to the active scenario. Patch attributes are updated as well."""        if self.patchsearchauto:            searchradius = self.blocksize * 1.4     # 1.4 x Block Size        else:            searchradius = max(float(self.blocksize), float(self.patchsearchradius))  # Maximum of Blocksize never less!        patches = self.scenario.get_assets_with_identifier("PatchID")  # Retrieves all patches        idcounter = 1        for curpatch in patches:            if curpatch.get_attribute("Status") == 0:                continue    # SKIP CONDITION #1 - Patch is not active, skip            z1 = curpatch.get_attribute("Elevation")            dz = []   # [ dz, dist, UBVector(), points tuple ]            pts1 = curpatch.get_points()            for nextpatch in patches:                if nextpatch.get_attribute("Status") == 0:                    continue    # SKIP CONDITION #0 - the next patch has no status                if nextpatch.get_attribute("PatchName") == curpatch.get_attribute("PatchName"):                    continue    # SKIP CONDITION #2 - Patches are equal, skip                pts2 = nextpatch.get_points()                current_dist = math.sqrt(pow(pts1[0] - pts2[0], 2) + pow(pts1[1] - pts2[1], 2))                if current_dist > searchradius:                    continue    # SKIP CONDITION #3 - Not within search radius                z2 = nextpatch.get_attribute("Elevation")                if z2 - z1 >= 0: # SKIP CONDITION #4 - Not lower elevation than current patch                    continue    # Not downstream                dz.append([z2-z1, current_dist, nextpatch, pts2])            # Now pick from the list and find the lower patch point            if len(dz) == 0:                curpatch.add_attribute("downPatch", "-1")                curpatch.add_attribute("downDist", 0)                curpatch.add_attribute("down_dz", 0)                continue            if self.patchflowmethod == "MAX":                dz.sort()            elif self.patchflowmethod == "MIN":                dz.sort(reverse=True)            elif self.patchflowmethod == "DIST":                dz.sort(key=lambda x: x[1])            downPatch = dz[0][2]  # first row, 2nd column            curpatch.add_attribute("downPatch", str(downPatch.get_attribute("PatchName")))            curpatch.add_attribute("downDist", float(dz[0][1]))            curpatch.add_attribute("down_dz", float(dz[0][0]))            # Create the Link            link = ubdata.UBVector((curpatch.get_points(), dz[0][3]))            link.add_attribute("PatchFloID", idcounter)            link.add_attribute("Upstream", curpatch.get_attribute("PatchName"))            link.add_attribute("Downstream", downPatch.get_attribute("PatchName"))            link.add_attribute("Distance", dz[0][1])            link.add_attribute("dZ", dz[0][0])            self.scenario.add_asset("PatchFloID"+str(idcounter), link)            idcounter += 1        return True    def find_open_space_distances(self, green_patches, grey_patches, non_patches):        """Calculates the location of the closest green space within the map. Considers PG and REF land uses. Distances        are calculated between the grey patches, which is a list of non-park patches and green patches.        :param green_patches: list containing UBVector() instances of all PG/REF patches in the map        :param grey_patches: list containing UBVector() instances fo all non PG/REF patches        :param non_patches: list containing UBVector() instances fo all patches that should not be considered        :return: Modifies the existing patch UBVector() instance and adds OSLink assets to the scenario        """        # Find the distance to nearest green space in all grey patches        oslink_id = 1        for grey in grey_patches:            prev_dist = 9999999999999999    # Initialize            pts_current = (0, 0)        # Initialize            current_green = None     # Initialize            pts1 = grey.get_points()            for green in green_patches:                pts2 = green.get_points()                current_dist = math.sqrt(pow(pts1[0] - pts2[0], 2) + pow(pts1[1] - pts2[1],2))                if current_dist < prev_dist:                    prev_dist = current_dist                    pts_current = pts2                    current_green = green                    grey.add_attribute("GSD_Dist", prev_dist)                    grey.add_attribute("GSD_Loc", str(green.get_attribute("BlockID"))+"_"+                                       str(green.get_attribute("PatchID")))                    grey.add_attribute("GSD_Deg", 0)                    grey.add_attribute("GSD_ACon", 0)            # Draw the link line            dist_line = ubdata.UBVector(((pts1[0], pts1[1]), (pts_current[0], pts_current[1])))            dist_line.add_attribute("OSLinkID", oslink_id)            dist_line.add_attribute("Distance", prev_dist)            dist_line.add_attribute("Location", grey.get_attribute("GSD_Loc"))            dist_line.add_attribute("Landuse", grey.get_attribute("Landuse"))            dist_line.add_attribute("AreaAccess", grey.get_attribute("PatchArea"))            dist_line.add_attribute("OS_Size", current_green.get_attribute("PatchArea"))            self.scenario.add_asset("OSLinkID"+str(oslink_id), dist_line)            oslink_id += 1        # For all green patches, write the same attributes and calculate the degree of connection        for green in green_patches:            patch_name = str(green.get_attribute("BlockID"))+"_"+str(green.get_attribute("PatchID"))            degree = 0            urban_area_connected = 0            for grey in grey_patches:                if grey.get_attribute("GSD_Loc") == patch_name:                    degree += 1                    urban_area_connected += grey.get_attribute("PatchArea")            green.add_attribute("GSD_Dist", 0)            green.add_attribute("GSD_Loc", str(green.get_attribute("BlockID"))+"_"+                                str(green.get_attribute("PatchID")))            green.add_attribute("GSD_Deg", degree)            green.add_attribute("GSD_ACon", urban_area_connected)        # For non-patches, add all default attributes        for non in non_patches:            non.add_attribute("GSD_Dist", -1)            non.add_attribute("GSD_Loc", "")            non.add_attribute("GSD_Deg", 0)            non.add_attribute("GSD_ACon", 0)        return True    def retrieve_patch_groups(self):        """Scans the simulation's patches and subdivides them into three groups based on land use. Returns three lists,        each containing all references to UBVector() objects with corresponding patch type.        :return: greenpatches (list of all PG and REF land use patchs), roadpatches (list of all RD patches), and                 greypathces (everything else)        """        # Get all patches in the collection        patches = self.scenario.get_assets_with_identifier("PatchID")     # Retrieves all patches        # From all the patches, sort out the open space patches as a separate array        greenpatches = []        greypatches = []        roadpatches = []        for i in patches:            if i.get_attribute("Landuse") in [10, 11, 15]:                greenpatches.append(i)            elif i.get_attribute("Landuse") in [8]:                roadpatches.append(i)            else:                greypatches.append(i)        return greenpatches, greypatches, roadpatches    def delineate_open_space_network(self, green_patches, grey_patches, non_patches, min_dist):        """Create a network of open spaces, only considers Parks and Reserves/Floodways        :param green_patches: a list containing UBVector() instances of green patches        :param grey_patches: a list of UBVector() instances of grey patches        :param non_patches: a list of UBVector() instances representing road patches        :return: modifies the existing patch data and adds OSNet assets to the scenario        """        osnet_id = 1        for g in green_patches:             # For each green patch, find the next closest patch            degrees = 0            pts1 = g.get_points()   # Get the patchXY            prev_dist = -1            for h in green_patches:                if h.get_attribute("BlockID") == g.get_attribute("BlockID") \                        and h.get_attribute("PatchID") == g.get_attribute("PatchID"):                    continue    # If it's the same patch, don't do anything!!                pts2 = h.get_points()                current_dist = math.sqrt(pow(pts1[0]-pts2[0], 2) + pow(pts1[1]-pts2[1], 2))                if current_dist <= min_dist:                    degrees += 1                    link = ubdata.UBVector(((pts1[0], pts1[1]), (pts2[0], pts2[1])))                    link.add_attribute("OSNetID", osnet_id)                    link.add_attribute("NodeA", str(g.get_attribute("BlockID")) + "_" +                                       str(g.get_attribute("PatchID")))                    link.add_attribute("NodeB", str(h.get_attribute("BlockID")) + "_" +                                       str(h.get_attribute("PatchID")))                    link.add_attribute("Distance", current_dist)                    self.scenario.add_asset("OSNetID" + str(osnet_id), link)                    osnet_id += 1                    if prev_dist == -1 or current_dist < prev_dist:                        prev_dist = current_dist            g.add_attribute("OSNet_Deg", degrees)            g.add_attribute("OSNet_MinD", prev_dist)        # Add the new attributes to all patches that aren't parks for completeness        for g in grey_patches:            g.add_attribute("OSNet_Deg", 0)            g.add_attribute("OSNet_MinD", -1)        for n in non_patches:            n.add_attribute("OSNet_Deg", 0)            n.add_attribute("OSNet_MinD", -1)        return True    def calculate_closest_waterbody(self, assetlist):        """Calculates the distance to the closest water body and the location of the closest water body.        :param assetlist: The list of active Blocks or Patches (UBVector() instances) within the simulation        :return: updates each Block with the "WBloc" and "WBdist" attributes.        """        if self.geometry_type in ["SQUARES", "HEXAGONS"]:            idtype = "BlockID"        elif self.geometry_type == "VECTORPATCH":            idtype = "PatchID"        wb_blocks = []        # Step 1 - Determine all river and lake assets and set their distances to zero and their location to their own        for b in assetlist:            if b.get_attribute("HasRiver") or b.get_attribute("HasLake"):                b.add_attribute("WBdist", 0)                b.add_attribute("WBloc", b.get_attribute(idtype))                wb_blocks.append(b)     # Append this block to a list of water body blocks for scanning later        # Step 2 - Now calculate for all remaining assets these distances and locations        for b in assetlist:            if b.get_attribute("HasRiver") or b.get_attribute("HasLake"):                continue            else:                prev_distance = 9999999999.9                bx = b.get_attribute("CentreX")                by = b.get_attribute("CentreY")                for c in wb_blocks:                    # Calculate distances from Block Centroids                    cx = c.get_attribute("CentreX")                    cy = c.get_attribute("CentreY")                    cur_distance = math.sqrt(pow(cx-bx, 2) + pow(cy-by, 2))                    if cur_distance < prev_distance:                        prev_distance = cur_distance                        b.add_attribute("WBdist", cur_distance)                        b.add_attribute("WBloc", c.get_attribute(idtype))        return True    def detect_lakes_in_assets(self, assetlist, lakeslist):        """Intersects all blocks with all lakes and transfers lake name to each Block.        :param assetlist: the list of active Blocks in the simulation        :param lakeslist: loaded UBVector() objects of lake polygons.        :return: modifies the existing UBVector() Block objects with "HasLake" and "LakeNames" attributes.        """        for i in range(len(assetlist)):            curasset = assetlist[i]            if curasset.get_attribute("Status") == 0:                continue            coordinates = curasset.get_points()            coordinates = [c[:2] for c in coordinates]            blockpoly = Polygon(coordinates)            haslake = 0            lakenames = []            for j in range(len(lakeslist)):                lakepoly = Polygon(lakeslist[j].get_points())                if not lakepoly.intersects(blockpoly):                    continue                lakename = lakeslist[j].get_attribute(self.lake_attname)                if lakename not in lakenames:                    lakenames.append(lakename)                haslake = 1            if haslake:                curasset.add_attribute("HasLake", 1)                curasset.add_attribute("LakeNames", lakenames)            else:                curasset.add_attribute("HasLake", 0)                curasset.add_attribute("LakeNames", [])        return True    def detect_rivers_in_assets(self, assetlist, riverslist):        """Intersects all Blocks or Patch Polygons with all rivers and transfers river information to each Asset.        :param assetlist: the list of active Blocks or Patches in the simulation        :param riverslist: loaded UBVector() objects of rivers.        :return: modifies all existing UBVector() Block Objects with "HasRiver" and "RiverNames" attributes.        """        for i in range(len(assetlist)):            curasset = assetlist[i]            if curasset.get_attribute("Status") == 0:                continue            coordinates = curasset.get_points()            coordinates = [c[:2] for c in coordinates]            blockpoly = Polygon(coordinates)            hasriver = 0            rivernames = []            for j in range(len(riverslist)):                path = LineString(riverslist[j].get_points())                if not path.intersects(blockpoly):                    continue                # If the current linestring intersects with the Block, then...                rivername = riverslist[j].get_attribute(self.river_attname)                if rivername not in rivernames:                    rivernames.append(rivername)                hasriver = 1            if hasriver:                curasset.add_attribute("HasRiver", 1)                curasset.add_attribute("RiverNames", rivernames)            else:                curasset.add_attribute("HasRiver", 0)                curasset.add_attribute("RiverNames", [])        return True    def detect_stormdrains_in_assets(self, assetlist, stormdrains):        """Intersects all Blocks with all stormwater drains and transfers drainage information to each Block.        :param assetlist: the list of active Blocks in the simulation        :param stormdrains: loaded UBVector() objects of stormwater drains        :return: modifies all existing UBVector() Block Objects with the "HasSWDrain" attribute.        """        for i in range(len(assetlist)):            curasset = assetlist[i]            if curasset.get_attribute("Status") == 0:                continue            coordinates = curasset.get_points()            coordinates = [(c[0], c[1]) for c in coordinates]            blockpoly = Polygon(coordinates)            hasdrain = 0            for j in range(len(stormdrains)):                path = LineString(stormdrains[j].get_points())                if not path.intersects(blockpoly):                    continue                hasdrain = 1            if hasdrain:                curasset.add_attribute("HasSWDrain", 1)            else:                curasset.add_attribute("HasSWDrain", 0)        return True    def create_block_flow_hashtable(self, blockslist):        """Creates a hash table of BlockIDs for quick lookup, this allows the basin delineation algorithm to rapidly        delineate the sub-catchment        :param blockslist: the list of UBVector() instances of all blocks in the map        :return: a 2D list [ [upstreamID], [downstreamID] ]        """        hash_table = [[], []]     # COL#1: BlockID (upstream), COL#2: BlockID (downstream)        for i in range(len(blockslist)):            current_block = blockslist[i]            current_id = current_block.get_attribute("BlockID")            if current_block.get_attribute("Status") == 0:                continue            hash_table[0].append(int(current_id))            hash_table[1].append(int(current_block.get_attribute("downID")))    # [ID or -2]        return hash_table    def delineate_basin_structures(self, blockslist):        """Delineates sub-basins across the entire blocksmap specified by the collection of blocks in 'blockslist'.        Returns the number of sub-basins in the map, but also writes BasinID information to each Block. Delineation is        carried out by creating a hash table of BlockID and downstream ID.        Each block is scanned and all its upstream and downstream Block IDs identified, each is also assigned a        BasinID.        :param blocklist: the list [] of UBVector() instances that represent Blocks        :return: number of total basins. Also writes the "BasinID" attribute to each Block.        """        hash_table = self.create_block_flow_hashtable(blockslist)    # Start by creating a hash tables        basin_id = 0    # Set Basin ID to zero, it will start counting up as soon as basins are found        for i in range(len(blockslist)):    # Loop  across all Blocks            current_block = blockslist[i]            if current_block.get_attribute("Status") == 0:                continue    # Skip if Status = 0            # Check if the Block is a single-basin Block            current_id = current_block.get_attribute("BlockID")            if current_id not in hash_table[1]:                 # If the current Block not downstream of something...                current_block.add_attribute("UpstrIDs", [])     # ...then it has NO upstream IDs (empty list)                if current_id in hash_table[0]:                 # ... if it is in the first column of the hash table                    if hash_table[1][hash_table[0].index(current_id)] == -2:    # if its second column is -2                        self.notify("Found a single block basin at BlockID"+str(current_id))                        basin_id += 1   # Then we have found a single-block Basin                        current_block.add_attribute("BasinID", basin_id)                        current_block.add_attribute("DownstrIDs", [])                        current_block.add_attribute("Outlet", 1)                        continue            # Search the current Block for its upstream IDs            upstream_ids = [current_id]         # Otherwise current ID DOES have upstream blocks            for uid in upstream_ids:             # Begin scanning! Note that upstream_ids will grow in length!                for j in range(len(hash_table[1])):                    if uid == hash_table[1][j]:                        if hash_table[0][j] not in upstream_ids:    # Only want unique upstream_ids!                            upstream_ids.append(hash_table[0][j])   # Slowly append more IDs to the hash_table            # Once scan is complete, remove the current Block's ID from the list as it is NOT upstream of itself.            upstream_ids.remove(current_id)            self.notify("BlockID"+str(current_id)+" Upstream: "+str(upstream_ids))            current_block.add_attribute("UpstrIDs", upstream_ids)            # Repeat the whole process now for the downstream IDs            downstream_ids = [current_id]            for uid in downstream_ids:                for j in range(len(hash_table[0])):                    if uid == hash_table[0][j]:                        if hash_table[1][j] not in downstream_ids:                            downstream_ids.append(hash_table[1][j])            # Once scan is complete, remove the current Block's ID from the list as it is NOT downstream of itself.            downstream_ids.remove(current_id)            # downstream_ids.remove(-2)   # Also remove the -2, which is specified if the Outlet Block is found            self.notify("BlockID"+str(current_id)+" DownstreamL "+str(downstream_ids))            current_block.add_attribute("DownstrIDs", downstream_ids)            # Now assign Basin IDs, do this if the current Block has downstream ID -2            if hash_table[1][hash_table[0].index(current_id)] == -2:    # If the block is an outlet                # print "Found a basin outlet at BlockID" + str(current_id)                self.notify("Found a basin outlet at BlockID"+str(current_id))                basin_id += 1                current_block.add_attribute("BasinID", basin_id)    # Set the current Basin ID                current_block.add_attribute("Outlet", 1)            # Outlet = TRUE at current Block                for j in upstream_ids:                    upblock = self.scenario.get_asset_with_name("BlockID"+str(int(j)))                    upblock.add_attribute("BasinID", basin_id)      # Assign basin ID to all upstream blocks                    upblock.add_attribute("Outlet", 0)              # Upstream blocks are NOT outlets!        self.notify("Total Basins in the Case Study: "+str(basin_id))        print(f"Total Basins in the Case Study: {basin_id}")        return basin_id     # The final count indicates how many basins were found    def delineate_flow_paths(self, blockslist):        """Delineates the flow paths according to the chosen method and saves the information to the blocks.        :param blockslist: a list [] of UBVector instances representing the Blocks        :return: all data is saved to the UBVector instances as new Block data.        """        sink_ids = []        river_blocks = []        lake_ids = []        for i in range(len(blockslist)):            current_block = blockslist[i]            current_blockid = current_block.get_attribute("BlockID")            # SKIP CONDITION 1 - Block has zero status            if current_block.get_attribute("Status") == 0:                continue            # SKIP CONDITION 2 - Block already contains a river            if current_block.get_attribute("HasRiver") and not self.ignore_rivers:                current_block.add_attribute("downID", -2)   # Immediately assign it the -2 value for downID                current_block.add_attribute("max_dz", 0)                current_block.add_attribute("avg_slope", 0)                current_block.add_attribute("h_pond", 0)  # Only for sink blocks will height of ponding h_pond > 0                river_blocks.append(current_block)                continue            # SKIP CONDITION 3 - Block contains a lake            if current_block.get_attribute("HasLake") and not self.ignore_lakes:                current_block.add_attribute("downID", -2)  # Immediately assign it the -2 value for downID                current_block.add_attribute("max_dz", 0)                current_block.add_attribute("avg_slope", 0)                current_block.add_attribute("h_pond", 0)  # Only for sink blocks will height of ponding h_pond > 0                lake_ids.append(current_blockid)                continue            z = current_block.get_attribute("AvgElev")            # Get the neighbouring elevations. This is either the full neighbourhood if we are not using natural or            # built features as a guide, or the full neighbourhood if neither features are in adjacent neighbour blocks.            # Otherwise the neighbour_z array will have only as many options as there are neighbours with natural or            # built features.            if self.guide_natural or self.guide_built:      # If we use natural or built features as a guide, then...                neighbours_z = self.get_modified_neighbours_z(current_block, "BlockID") # ret. [[BlockID], [Elevation]]                if neighbours_z is None:        # If the current block has no natural or built features adjacent...                    neighbours_z = self.scenario.retrieve_attribute_value_list("Block", "AvgElev",                                                                               current_block.get_attribute(                                                                                   "Neighbours"))            else:                neighbours_z = self.scenario.retrieve_attribute_value_list("Block", "AvgElev",                                                                           current_block.get_attribute("Neighbours"))            # print(f"Neighbour Z: {neighbours_z}")            # Find the downstream block unless it's a sink            if self.flowpath_method == "D8":        # Directional pathways, largest Z-drop                flow_id, max_zdrop = self.find_downstream_d8(z, neighbours_z)            elif self.flowpath_method == "DI" and self.neighbourhood == "M":                # Only works for the Moore neighbourhood                flow_id, max_zdrop = self.find_downstream_dinf(z, neighbours_z)            else:                self.flowpath_method = "D8"     # Reset to D8 by default                flow_id, max_zdrop = self.find_downstream_d8(z, neighbours_z)            if flow_id == -9999:     # if no flowpath has been found                sink_ids.append(current_blockid)                downstream_id = -1  # Block is a possible sink. if -2 --> block is a catchment outlet            else:                downstream_id = flow_id            # Grab distances / slope between two Block IDs            if flow_id == -9999:                avg_slope = 0            else:                down_block = self.scenario.get_asset_with_name("BlockID"+str(downstream_id))                dx = current_block.get_attribute("CentreX") - down_block.get_attribute("CentreX")                dy = current_block.get_attribute("CentreY") - down_block.get_attribute("CentreY")                dist = float(math.sqrt((dx * dx) + (dy * dy)))                avg_slope = max_zdrop / dist            # Add attributes            current_block.add_attribute("downID", downstream_id)            current_block.add_attribute("max_dz", max_zdrop)            current_block.add_attribute("avg_slope", avg_slope)            current_block.add_attribute("h_pond", 0)    # Only for sink blocks will height of ponding h_pond > 0            # Draw Networks            if downstream_id != -1 and downstream_id != 0:                network_link = self.draw_flow_path(current_block, 1, "BlockID", "Centre")                self.scenario.add_asset("FlowID"+str(current_blockid), network_link)        # Unblock the Sinks        self.unblock_sinks(sink_ids, "BlockID", "Centre")        if self.map_attr.get_attribute("HasRIVER"):            self.connect_river_assets(river_blocks)   # [TO DO]        return True    def get_modified_neighbours_z(self, curasset, idtype):        """Retrieves the z-values of all adjacent blocks within the current block's neighbourhood accounting for        the presence of drainage infrastructure or natural features.        :param curasset: the current block UBVector() instance        :return: a list of z-values for all the block's neighbours [ [BlockID], [Z-value] ], None otherwise        """        nhd = curasset.get_attribute("Neighbours")        nhd_z = [[],[]]        # Scan neighbourhood for Blocks with Rivers/Lakes        for n in nhd:            nblock = self.scenario.get_asset_with_name(idtype+str(n))            if self.guide_natural:                if nblock.get_attribute("HasRiver") or nblock.get_attribute("HasLake"):                    nhd_z[0].append(n)                    nhd_z[1].append(nblock.get_attribute("AvgElev"))            if self.guide_built:                if nblock.get_attribute("HasSWDrain") and n not in nhd_z[0]:                    nhd_z[0].append(n)                    nhd_z[1].append(nblock.get_attribute("AvgElev"))        if len(nhd_z[0]) == 0:            return None        else:            return nhd_z    def connect_river_assets(self, river_blocks):        """Scans the blocks for those containing a river system and connects them based on adjacency and river        rules.        :param river_blocks: the list () of block UBVector() instances with HasRiver == 1.        :return: Each block is given a new attribute specifying the Block containing a river that it drains into        """        # Connect blocks in logical order, probably based on the linestrings of the river        pass    # Scan block list, if HasRiver true, then check neighbours, if they have river and river name is                # identical, connect, otherwise specify -1 as unconnected        return True # [TO DO]    def unblock_sinks(self, sink_ids, idtype, pt_attribute):        """Runs the algorithm for scanning all sink blocks and attempting to find a flowpath beyond them.        This function may also identify certain sinks as definitive catchment outlets.        :param blockslist: the list [] of block UBVector instances        :param sink_ids: a list of BlockIDs where a sink is believe to exist based on the flowpath method.        :return: adds new assets to the scenario if a flowpath has been found for the sinks        """        for i in range(len(sink_ids)):            current_sinkid = sink_ids[i]            self.notify("Attemtping to unblock flow from "+ idtype + str(current_sinkid))            curasset = self.scenario.get_asset_with_name(idtype+str(current_sinkid))            if curasset.get_attribute("HasRiver") or curasset.get_attribute("HasLake"):                # If the Block is a river or lake block, do not attempt to unblock it                curasset.set_attribute("downID", -2)  # signifies that Block is an outlet                continue            z = curasset.get_attribute("AvgElev")            nhd = curasset.get_attribute("Neighbours")            possible_id_drains = []            possible_id_z = []            possibility = 0            for j in nhd:                nhd_blk = self.scenario.get_asset_with_name(idtype+str(j))                if nhd_blk.get_attribute("Status") == 0:                    continue    # Continue if nhd block has zero status                nhd_downid = nhd_blk.get_attribute("downID")                if nhd_downid not in [current_sinkid, -1] and nhd_downid not in nhd:                    possible_id_drains.append(j)                    possible_id_z.append(nhd_blk.get_attribute("AvgElev") - z)                    possibility += 1            if possibility > 0:                sink_path = min(possible_id_z)                sink_to_id = possible_id_drains[possible_id_z.index(sink_path)]                curasset.set_attribute("downID", sink_to_id)   # Overwrite -1 to new ID                curasset.set_attribute("h_pond", sink_path)    # If ponding depth > 0, then there was a sink                network_link = self.draw_flow_path(curasset, "Ponded", idtype, pt_attribute)                self.scenario.add_asset("FlowID" + str(curasset.get_attribute("BlockID")), network_link)            else:                curasset.set_attribute("downID", -2)   # signifies that Block is an outlet        return True    def draw_flow_path(self, curasset, flow_type, idtype, pt_attribute):        """Creates the flowpath geometry and returns a line asset, which can be saved to the scenario.        :param curasset: current ID of the block that the flowpath is being drawn for        :param flow_type: type of flowpath e.g. "Regular", "Ponded"        :return: UBVector() instance of a network link        """        current_id = curasset.get_attribute(idtype)        downstream_id = curasset.get_attribute("downID")        down_block = self.scenario.get_asset_with_name(idtype+str(downstream_id))        x_up = curasset.get_attribute(pt_attribute+"X")        y_up = curasset.get_attribute(pt_attribute+"Y")        z_up = curasset.get_attribute("AvgElev")        up_point = (x_up, y_up, z_up)        x_down = down_block.get_attribute(pt_attribute+"X")        y_down = down_block.get_attribute(pt_attribute+"Y")        z_down = down_block.get_attribute("AvgElev")        down_point = (x_down, y_down, z_down)        network_link = ubdata.UBVector((up_point, down_point))        network_link.determine_geometry((up_point, down_point))        network_link.add_attribute("FlowID", current_id)        network_link.add_attribute(idtype, current_id)        network_link.add_attribute("DownID", downstream_id)        network_link.add_attribute("Z_up", z_up)        network_link.add_attribute("Z_down", z_down)        network_link.add_attribute("max_zdrop", curasset.get_attribute("max_dz"))        network_link.add_attribute("LinkType", flow_type)        network_link.add_attribute("AvgSlope", curasset.get_attribute("avg_slope"))        network_link.add_attribute("h_pond", curasset.get_attribute("h_pond"))        return network_link    def find_downstream_d8(self, z, nhd_z):        """Uses the standard D8 method to find the downstream neighbouring block. Return the BlockID        and the delta-Z value of the drop. Elevation difference is calculated as dz = [NHD_Z - Z] and is        negative if the neighbouring Block has a lower elevation than the central Block.        :param z: elevation of the current central Block        :param nhd_z: elevation of all its neighbours and corresponding IDs [[IDs], [Z-values]]        :return: down_id: block ID that water drains to, min(dz) the largest elevation difference.        """        dz = []        for i in range(len(nhd_z[1])):            dz.append(nhd_z[1][i] - z)     # Calculate the elevation difference        if min(dz) < 0:    # If there is a drop in elevation - this also means the area cannot be flat!            down_id = nhd_z[0][dz.index(min(dz))]    # The ID corresponds to the minimum elevation difference        else:            down_id = -9999  # Otherwise there is a sink in the current Block        return down_id, min(dz)    def find_downstream_dinf(self, z, nhd_z):        """Adapted D-infinity method to only direct water in one direction based on the steepest slope        of the 8 triangular facets surrounding a Block's neighbourhood and a probabilistic choice weighted        by the propotioning of flow. This is the stochastic option of flowpath delineation for UrbanBEATS        and ONLY works with the Moore neighbourhood.        :param z: elevation of the current central Block        :param nhd_z: :param nhd_z: elevation of all its neighbours and corresponding IDs [[IDs], [Z-values]]        :return:        """        pass    # [TO DO]        # FROM LEGACY CODE        # facetdict = {}  # Stores all the information about the 8 facets        # facetdict["e1"] = ["E", "N", "N", "W", "W", "S", "S", "E"]        # facetdict["e2"] = ["NE", "NE", "NW", "NW", "SW", "SW", "SE", "SE"]        # facetdict["ac"] = [0, 1, 1, 2, 2, 3, 3, 4]        # facetdict["af"] = [1, -1, 1, -1, 1, -1, 1, -1]        # cardin = {"E": 0, "NE": 1, "N": 2, "NW": 3, "W": 4, "SW": 5, "S": 6, "SE": 7}        #        # e0 = currentZ  # CONSTANT PARAMETERS (because of constant block grid and centre point)        # d1 = blocksize        # d2 = d1        # facetangles = [0, math.pi / 4, math.pi / 2, 3 * math.pi / 4, math.pi, 5 * math.pi / 4, 3 * math.pi / 2,        #                7 * math.pi / 4]        #        # # Re-sort the neighbours matrix based on polar angle        # sortedneighb = [neighboursZ[3], neighboursZ[4], neighboursZ[0], neighboursZ[5], neighboursZ[2], neighboursZ[7],        #                 neighboursZ[1], neighboursZ[6]]        # rmatrix = []        # smatrix = []        #        # for i in range(len(sortedneighb)):  # Calculate slopes of all 8 facets        #     currentfacet = i        #        #     e1 = sortedneighb[        #         cardin[facetdict["e1"][currentfacet]]]  # e1 elevation:  (1) get cardinal direction from dictionary,        #     #               (2) get the index from cardin and        #     e2 = sortedneighb[cardin[facetdict["e2"][currentfacet]]]  # (3) get the value from neighbz        #        #     ac = facetdict["ac"][currentfacet]        #     af = facetdict["af"][currentfacet]        #        #     s1 = (e0 - e1) / d1        #     s2 = (e1 - e2) / d2        #     r = math.atan(s2 / s1)        #     s = math.sqrt(math.pow(s1, 2) + math.pow(s2, 2))        #        #     if r < 0:        #         r = 0        #         s = s1        #     elif r > math.atan(d2 / d1):        #         r = math.atan(d2 / d1)        #         s = (e0 - e2) / math.sqrt(math.pow(d1, 2) + math.pow(d2, 2))        #        #     rmatrix.append(r)        #     smatrix.append(s)        #        # # Find the maximum slope and get the angle        # rmax = max(rmatrix)        # rg = af * rmax + ac * math.pi / 2.0        #        # # Find the facet        # for i in range(len(facetangles)):        #     if rg > facetangles[i]:        #         continue        #     else:        #         facet = i - 1        #         theta1 = facetangles[i - 1]        #         theta2 = facetangles[i]        # # Adjust angles based on rg to get proportions        # alpha1 = rg - theta1        # alpha2 = theta2 - rg        # p1 = alpha1 / (alpha1 + alpha2)        # p2 = alpha2 / (alpha2 + alpha1)        #        # print(f"Proportioned Flows: {p1}, {p2}")        #        # if rand.random() < p1:        #     choice = p1        #     directionfacet = int(theta1 / (math.pi / 4))        # else:        #     choice = p2        #     directionfacet = int(theta2 / (math.pi / 4))        #        # print(f"Choice: {choice}")        #        # direction = neighboursZ.index(sortedneighb[directionfacet - 1])        # return direction, max_Zdrop        return True    def perform_smooth_dem(self, blockslist):        """Performs a smoothing of the DEM on the Blocks map. This is only necessary if the DEM is quite        tricky to work with and flowpaths are not behaving the way you intend for them to behave.        :param blockslist: a list [] of the block assets in UBVector objects.        """        for i in range(len(self.dem_passes)):            new_elevs = {}            for b in range(len(blockslist)):                current_block = blockslist[i]                elevs = [current_block.get_attribute("Elevation")]                neighbours = current_block.get_attribute("Neighbours")                for n in neighbours:                    ne_block = self.scenario.get_asset_with_name("BlockID"+str(n)).get_attribute("Elevation")                    elevs.append(ne_block)                # print(elevs)                # print(float(sum(elevs)/len(elevs)))                new_elevs[str(current_block.get_attribute("BlockID"))] = float(sum(elevs) / len(elevs))            for b in range(len(blockslist)):                blockslist[i].set_attribute("Elevation", new_elevs[str(blockslist[i].get_attribute("BlockID"))])        return True