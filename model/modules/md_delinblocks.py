# -*- coding: utf-8 -*-"""@file   md_delinblocks.py@author Peter M Bach <peterbach@gmail.com>@section LICENSEUrban Biophysical Environments and Technologies Simulator (UrbanBEATS)Copyright (C) 2018  Peter M. BachThis program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>."""__author__ = "Peter M. Bach"__copyright__ = "Copyright 2018. Peter M. Bach"# --- CODE STRUCTURE ---#       (1) Class Definition#           1.1 __init__() - primarily for parameter list#           1.2 run() - the module algorithm#           1.3 supplementary functions - all other modularised functions belonging to the module# --- --- --- --- --- ---# --- PYTHON LIBRARY IMPORTS ---import mathimport random as randimport threadingimport osimport gcimport tempfileimport mathimport timefrom shapely.geometry import Polygon, LineString# --- URBANBEATS LIBRARY IMPORTS ---from ubmodule import *import model.ublibs.ubspatial as ubspatialimport model.ublibs.ubmethods as ubmethodsimport model.ublibs.ubdatatypes as ubdataimport model.progref.ubglobals as ubglobals# --- MODULE CLASS DEFINITION ---class DelinBlocks(UBModule):    """ SPATIAL SETUP MODULE - Codename: DelinBlocks    Loads the spatial maps into the model core and processes them into Blocks. Also performs spatial connectivity    analysis and prepares all spatial input data in a ready-to-use format for all other modules. Links loaded data    sets into the model.    """    def __init__(self, activesim, scenario, datalibrary, projectlog, simulationyear):        """Initialises UBModule followed by full parameter list definition."""        UBModule.__init__(self)        self.name = "Delineation and Spatial Setup Module"        self.simulationyear = simulationyear        # CONNECTIONS WITH CORE SIMULATION        self.activesim = activesim      # The current active UBSimulation() object from urbanbeatscore.py        self.scenario = scenario        # The current active UBScenario() object        self.datalibrary = datalibrary  # The active data library UBDataLibrary()        self.projectlog = projectlog    # Active project log        # PARAMETER LIST DEFINITION        # (Tab 1.1) ESSENTIAL SPATIAL DATA SETS        self.create_parameter("landuse_map", STRING, "land use map filepath")        self.create_parameter("population_map", STRING, "population map filepath")        self.create_parameter("elevation_map", STRING, "elevation map filepath")        self.create_parameter("landuse_fud", BOOL, "use urban development land use?")        self.create_parameter("population_fud", BOOL, "use urban development population?")        self.landuse_map = ""        self.population_map = ""        self.elevation_map = ""        self.landuse_fud = 0        self.population_fud = 0        # (Tab 1.2) SPATIAL GEOMETRY        self.create_parameter("geometry_type", STRING, "block or future types of geometry e.g. hex")        self.geometry_type = "BLOCKS"  # BLOCKS, HEXAGONS, VECTORPATCH        # 1.2.1 BLOCKS        self.create_parameter("blocksize", DOUBLE, "resolution of the discretisation grid")        self.create_parameter("blocksize_auto", BOOL, "determine resolution automatically?")        self.create_parameter("neighbourhood", STRING, "type of neighbourhood to use, Moore or vN")        self.create_parameter("patchdelin", BOOL, "delineate patches?")        self.create_parameter("spatialmetrics", BOOL, "calculate spatial metrics?")        self.blocksize = 500        self.blocksize_auto = 0        self.neighbourhood = "M"    # M (Moore) or V (von Neumann)        self.patchdelin = 1        self.spatialmetrics = 1        # 1.2.2 HEXAGONS    [TO DO]        # 1.2.3 VECTORPATCHES [TO DO]        # (Tab 2.1) JURISDICTIONAL AND SUBURBAN BOUNDARIES        self.create_parameter("include_geopolitical", BOOL, "include geopolitical map?")        self.create_parameter("geopolitical_map", STRING, "geopolitical map filepath")        self.create_parameter("geopolitical_attref", STRING, "attribute name reference")        self.create_parameter("include_suburb", BOOL, "include suburban map?")        self.create_parameter("suburban_map", STRING, "suburban map filepath")        self.create_parameter("suburban_attref", STRING, "attribute name reference")        self.create_parameter("include_planzone", BOOL, "include suburban map?")        self.create_parameter("planzone_map", STRING, "suburban map filepath")        self.create_parameter("planzone_attref", STRING, "attribute name reference")        self.include_geopolitical = 0        self.geopolitical_map = ""        self.geopolitical_attref = ""        self.include_suburb = 0        self.suburban_map = ""        self.suburban_attref = ""        self.include_planzone = 0        self.planzone_map = ""        self.planzone_attref = ""        # (Tab 2.2) CENTRAL BUSINESS DISTRICT        self.create_parameter("considerCBD", BOOL, "consider CBD Location?")        self.create_parameter("locationOption", STRING, "method for inputting CBD location")        self.create_parameter("locationCity", STRING, "city name")        self.create_parameter("locationLong", DOUBLE, "CBD Longitude")        self.create_parameter("locationLat", DOUBLE, "CBD Latitude")        self.create_parameter("marklocation", BOOL, "mark location on output map")        self.considerCBD = 0        self.locationOption = "S"   # S = Selection, C = coordinates        self.locationCity = self.activesim.get_project_parameter("city")        self.locationLong = float(0.0)        self.locationLat = float(0.0)        self.marklocation = 0        # (Tab 2.3) OPEN SPACE NETWORK        self.create_parameter("osnet_accessibility", BOOL, "Calculate accessibility?")        self.create_parameter("osnet_network", BOOL, "Delineate open space network?")        self.osnet_accessibility = 0        self.osnet_network = 0        # (Tab 3.1) MAJOR WATER FEATURES        self.create_parameter("include_rivers", BOOL, "include a rivers map into simulation?")        self.create_parameter("include_lakes", BOOL, "include a ponds and lakes map into simulation?")        self.create_parameter("calculate_wbdistance", BOOL, "calculate distance to closest water body?")        self.create_parameter("river_map", STRING, "river map data reference ID")        self.create_parameter("river_attname", STRING, "river map identifier attribute name")        self.create_parameter("lake_map", STRING, "ponds and lake map data reference ID")        self.create_parameter("lake_attname", STRING, "lake map identifier attribute name")        self.include_rivers = 0        self.include_lakes = 0        self.calculate_wbdistance = 0        self.river_map = ""        self.river_attname = ""        self.lake_map = ""        self.lake_attname = ""        # (Tab 3.2) BUILT WATER INFRASTRUCTURE #[TO DO]        self.create_parameter("include_storm", BOOL, "include stormwater drainage infrastructure")        self.create_parameter("include_sewer", BOOL, "include wastewater infrastructure")        self.create_parameter("include_supply", BOOL, "include water supply infrastructure")        self.create_parameter("storm_map", STRING, "stormwater drainage infrastructure map data reference ID")        self.create_parameter("sewer_map", STRING, "sewer infrastructure map data reference ID")        self.create_parameter("supply_map", STRING, "water supply map data reference ID")        self.include_storm = 0        self.include_sewer = 0        self.include_supply = 0        self.storm_map = ""        self.sewer_map = ""        self.supply_map = ""        # (Tab 3.3) STORMWATER DRAINAGE FLOW PATHS        self.create_parameter("flowpaths", BOOL, "delineate drainage flow paths and subcatchments?")        self.create_parameter("flowpath_method", STRING, "flowpath method to use")        self.create_parameter("dem_smooth", BOOL, "smooth DEM map before doing flowpath delineation?")        self.create_parameter("dem_passes", DOUBLE, "number of passes for smoothing")        self.create_parameter("guide_natural", BOOL, "guide flowpath delineation using pre-loaded natural feature?")        self.create_parameter("guide_built", BOOL, "guide flowpath delineation using built infrastructure?")        self.create_parameter("ignore_rivers", BOOL, "ignore river features in the delineation of outlets")        self.create_parameter("ignore_lakes", BOOL, "ignore lake features in the delineation of outlets")        self.flowpaths = 1        self.flowpath_method = "D8"        self.dem_smooth = 0        self.dem_passes = 1        self.guide_natural = 0        self.guide_built = 0        self.ignore_rivers = 0        self.ignore_lakes = 0        self.create_parameter("patchflowpaths", BOOL, "delineate drainage flow paths for patches?")        self.create_parameter("patchflowmethod", STRING, "flowpath method to use")        self.create_parameter("patchsearchradius", DOUBLE, "search radius to use for the patch flow paths?")        self.create_parameter("patchsearchauto", BOOL, "auto-determine the search radius?")        self.patchflowpaths = 1        self.patchflowmethod = "MAX"    # MAX = max drop, MIN = min drop, DIST = closest distance drop        self.patchsearchradius = 500.0        self.patchsearchauto = 1    # Auto == True --> 1.4 Block size        # NON-VISIBLE PARAMETER LIST - USED THROUGHOUT THE SIMULATION        self.xllcorner = float(0.0)     # Obtained from the loaded raster data (elevation) upon run-time        self.yllcorner = float(0.0)     # Spatial extents of the input map        self.final_bs = self.blocksize  # Final_bs = final block size - this is determined at the start        self.elevation = 0        self.landuse = 0        self.population = 0        self.municipal_boundary = 0        self.suburban_boundary = 0        # ----- END OF INPUT PARAMETER LIST -----    def run_module(self):        """Contains the main algorithm for the module, links with all other functions thereafter. This is called by        UrbanBEATSSim() simulation's scenario manager depending on which scenario is currently being simulated.        :return: True upon successful completion        """        self.notify("Start Spatial Delineation Module")     # Module start        print "Start Spatial Delineation Module"        rand.seed()     # Seed the random number generator        # --- SECTION 1 - PREPARATION FOR CREATING THE GRIDDED MAP BASED ON THE INPUT BOUNDARY MAP ---        # Check the neighbourhood rule and set the number of adjacent cells, nhd_type, accordingly        # This is only used for attribute saving, i.e. could remove this and use "M" and "V" instead.        if self.neighbourhood == "M":   # Determine number of neighbour cells depending on the neighbourhood            nhd_type = 8    # 8 cardinal directions        else:            nhd_type = 4    # 4 adjacent cells NSEW        # GET BOUNDARY EXTENTS AND WORK OUT THE MAP DIMENSIONS        xmin, xmax, ymin, ymax = self.activesim.get_project_boundary_info("mapextents")        mapwidth = xmax - xmin      # width of the map [m]        mapheight = ymax - ymin     # height of map [m]        Amap_rect = mapwidth * mapheight    # Total area of the rectangular extents [m]        if self.blocksize_auto:     # AUTO-SIZE Blocks            bs = ubmethods.autosize_blocks(mapwidth, mapheight)            self.final_bs = bs        else:            bs = self.blocksize            self.final_bs = bs        self.notify("Map Width [km] = "+str(mapwidth/1000.0))        self.notify("Map Height [km] = "+str(mapheight/1000.0))        self.notify("Extent Area WxH [km2] = "+str(Amap_rect/1000000.0))        self.notify("Final Block Size [m] = "+str(bs))        self.notify("---===---")        print("Map Width [km] = " + str(mapwidth / 1000.0))        print("Map Height [km] = " + str(mapheight / 1000.0))        print("Extent Area WxH [km2] = " + str(Amap_rect / 1000000.0))        print("Final Block Size [m] = " + str(bs))        print("---===---")        # START CREATING BLOCKS MAP        self.notify("Creating Blocks Map!")        print("Creating Blocks Map!")        # ADJUST SIMULATION AREA DIMENSIONS        blocks_wide = int(math.ceil(mapwidth / float(bs)))      # To figure out how many blocks wide and tall, we use        blocks_tall = int(math.ceil(mapheight / float(bs)))     # math.ceil(), which rounds the number up.        numblocks = blocks_wide * blocks_tall        self.notify("Blocks wide: "+str(blocks_wide))        self.notify("Blocks tall: "+str(blocks_tall))        self.notify("Total number of Blocks: "+str(numblocks))        print("Blocks wide: " + str(blocks_wide))        print("Blocks tall: " + str(blocks_tall))        print("Total number of Blocks: " + str(numblocks))        # CBD DISTANCE CALCULATIONS [TO DO]        # Look up long and lat of CBD if need to be considered        if self.considerCBD:        # [TO DO]            # Grab CBD Coordinates and transform to the local coordinate system            pass        if self.marklocation:            # Mark locations on the map            pass        # MAP ATTRIBUTES - CREATE THE FIRST UBCOMPONENT() to save off basic map attributes.        map_attr = ubdata.UBComponent()        map_attr.add_attribute("xllcorner", xmin)       # The geographic coordinate x-pos of the actual map        map_attr.add_attribute("yllcorner", ymin)       # The geographic coordinate y-pos of the actual map        map_attr.add_attribute("Neigh_Type", nhd_type)        map_attr.add_attribute("spatialmetrics", self.spatialmetrics)        map_attr.add_attribute("considerCBD", self.considerCBD)        map_attr.add_attribute("patchdelin", self.patchdelin)  # Optional with Blocks and Hexes        # Attributes for Block-based Representation        map_attr.add_attribute("NumBlocks", numblocks)        map_attr.add_attribute("BlocksWide", blocks_wide)        map_attr.add_attribute("BlocksTall", blocks_tall)  # Height of simulation area in # of blocks        map_attr.add_attribute("BlockSize", bs)  # Size of block [m]        self.scenario.add_asset("MapAttributes", map_attr)        # --- SECTION 2 - DRAW THE MAP OF BLOCKS AND DETERMINE ACTIVE AND INACTIVE BLOCKS , NEIGHBOURHOODS ---        # Get the coordinates for the boundary of the map, this is used to check if the Block is active or inactive        boundarygeom = self.activesim.get_project_boundary_info("coordinates")        boundarygeom_zeroorigin = []    # Contains the polygon's coordinates shifted to the zero origin        for coord in boundarygeom:      # Shift the map to (0,0) origin            boundarygeom_zeroorigin.append(( coord[0] - xmin, coord[1] - ymin))        boundarypoly = Polygon(boundarygeom_zeroorigin)     # Test intersect with Block Polygon later using        blockIDcount = 1    # Counter for BlockID, initialized here        blockslist = []        print("Creating Block Geometry...")        for y in range(blocks_tall):        # Loop across the number of blocks tall and blocks wide            for x in range(blocks_wide):                # self.notify("Current BLOCK ID: "+str(blockIDcount))                # print("Current BLOCK ID: " + str(blockIDcount))                # - STEP 1 - CREATE BLOCK GEOMETRY                current_block = self.create_block_face(x, y, bs, blockIDcount, boundarypoly)                if current_block is None:       # current_block is UBVector() type otherwise                    blockIDcount += 1  # Increase the Block ID Count by one                    continue                xcentre = x * bs + 0.5 * bs                ycentre = y * bs + 0.5 * bs                xorigin = x * bs                yorigin = y * bs                current_block.add_attribute("CentreX", xcentre)    # ATTRIBUTE: geographic information                current_block.add_attribute("CentreY", ycentre)                current_block.add_attribute("OriginX", xorigin)                current_block.add_attribute("OriginY", yorigin)                current_block.add_attribute("Status", 1)    # Start with Status = 1 by default                self.scenario.add_asset("BlockID"+str(blockIDcount), current_block)     # Add the asset to the scenario                blockslist.append(current_block)                blockIDcount += 1       # Increase the Block ID Count by one        # - STEP 2 - GET BASIC RASTER DATA SETS        # Depending on what's available, certain options can be chosen        #   - Land use: + population, will allow the model to do urban planning        #   - Elevation: will allow the model to do Flowpath delineation        self.notify("Loading Basic Input Maps")        print("Loading Basic Input Maps")        # STEP 2.1 :: Load Land Use Map        if self.landuse_map:            lu_dref = self.datalibrary.get_data_with_id(self.landuse_map)       # Retrieve the land use data reference            fullfilepath = lu_dref.get_data_file_path() + lu_dref.get_metadata("filename")            self.notify("Loading: "+str(fullfilepath))            print("Loading: " + str(fullfilepath))            landuseraster = ubspatial.import_ascii_raster(fullfilepath, self.landuse_map)            self.notify("Load Complete!")            print("Load Complete!")            landuse_offset = ubspatial.calculate_offsets(landuseraster, map_attr)            luc_res = landuseraster.get_cellsize()            csc = int(math.ceil(bs / luc_res))  # csc = cell selection count - knowing how many cells wide and tall            # STEP 2.2 :: Assign land use to Blocks            for i in range(len(blockslist)):                current_block = blockslist[i]                col_origin = int(current_block.get_attribute("OriginX") / luc_res)                col_start_adj, cscx = ubspatial.adjust_position_by_offset(col_origin, landuse_offset[0], csc)                row_origin = int(current_block.get_attribute("OriginY") / luc_res)                row_start_adj, cscy = ubspatial.adjust_position_by_offset(row_origin, landuse_offset[1], csc)                lucdatamatrix = landuseraster.get_data_square(col_start_adj, row_start_adj, cscx, cscy)                # STEP 2.2.1 - Tally Frequency of Land uses                landclassprop, activity = ubmethods.calculate_frequency_of_lu_classes(lucdatamatrix)                # print current_block.get_attribute("BlockID"), "LUC Props: ", landclassprop                if activity == 0:                    blockstatus = 0                else:                    blockstatus = 1                current_block.set_attribute("Status", blockstatus)                current_block.add_attribute("Active", activity)                # Land use proportions in block (multiply with block area to get Area                current_block.add_attribute("pLU_RES", landclassprop[0])    # RES = Residential                current_block.add_attribute("pLU_COM", landclassprop[1])    # COM = Commercial                current_block.add_attribute("pLU_ORC", landclassprop[2])    # ORC = Mixed Office/Res Development                current_block.add_attribute("pLU_LI", landclassprop[3])     # LI = Light Industry                current_block.add_attribute("pLU_HI", landclassprop[4])     # HI = Heavy Industry                current_block.add_attribute("pLU_CIV", landclassprop[5])    # CIV = Civic                current_block.add_attribute("pLU_SVU", landclassprop[6])    # SVU = Service & Utility Land                current_block.add_attribute("pLU_RD", landclassprop[7])     # RD = Road                current_block.add_attribute("pLU_TR", landclassprop[8])     # TR = Transport Facility                current_block.add_attribute("pLU_PG", landclassprop[9])     # PG = Parks & Garden                current_block.add_attribute("pLU_REF", landclassprop[10])   # REF = Reserves & Floodways                current_block.add_attribute("pLU_UND", landclassprop[11])   # UND = Undeveloped                current_block.add_attribute("pLU_NA", landclassprop[12])    # NA = Unclassified                current_block.add_attribute("pLU_WAT", landclassprop[12])  # WAT = Water                current_block.add_attribute("pLU_FOR", landclassprop[12])  # FOR = Forest                current_block.add_attribute("pLU_AGR", landclassprop[12])  # AGR = Agriculture                map_attr.set_attribute("HasLUC", 1)                # STEP 2.2.2 - Calculate Spatial Metrics                if self.spatialmetrics and blockstatus:     # Using the land class proportions                    richness = ubmethods.calculate_metric_richness(landclassprop)                    shdiv, shdom, sheven = ubmethods.calculate_metric_shannon(landclassprop, richness)                    current_block.add_attribute("Rich", richness)                    current_block.add_attribute("ShDiv", shdiv)                    current_block.add_attribute("ShDom", shdom)                    current_block.add_attribute("ShEven", sheven)                    map_attr.add_attribute("HasSPATIALMETRICS", 1)                # STEP 2.2.3 - Delineate Patches if necessary                if self.patchdelin and blockstatus:     # If the user wishes to delineate patches...                    patchIDs = []                    blockpatches = ubmethods.patchdelin_landscape_patch_delineation(lucdatamatrix,                                                                                    landuseraster.get_nodatavalue())                    for p in range(len(blockpatches)):      # Scan all patches in the Block, transfer information.                        if blockpatches[p]["Landuse"] == landuseraster.get_nodatavalue():                            continue                        patchxy = (blockpatches[p]["Centroid_xy"][0] * luc_res + current_block.get_attribute("OriginX"),                                   blockpatches[p]["Centroid_xy"][1] * luc_res + current_block.get_attribute("OriginY"))                        # Points X and Y are based on the Centroid, calculated                        bID = current_block.get_attribute("BlockID")                        patcharea = blockpatches[p]["PatchSize"] * luc_res * luc_res                        patch_buffer_radius = math.sqrt(patcharea / math.pi)                        patch_attr = ubdata.UBVector(patchxy)                        patch_attr.add_attribute("PatchID", blockpatches[p]["PatchID"])   # PatchID counts from 1 to N                        patch_attr.add_attribute("PatchName", "B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]))                        patch_attr.add_attribute("PatchIndices", blockpatches[p]["PatchIndices"])                        patch_attr.add_attribute("Status", 1)       # Used for exporting and working with patches                        patch_attr.add_attribute("Landuse", blockpatches[p]["Landuse"])                        patch_attr.add_attribute("CentroidX", patchxy[0])                        patch_attr.add_attribute("CentroidY", patchxy[1])                        patch_attr.add_attribute("AspRatio", blockpatches[p]["AspRatio"])                        patch_attr.add_attribute("PatchSize", blockpatches[p]["PatchSize"])                        patch_attr.add_attribute("PatchArea", patcharea)                        patch_attr.add_attribute("BuffRadius", patch_buffer_radius)                        # Save the patch to the scenario as B#_PatchID#                        patch_attr.add_attribute("BlockID", bID)                        self.scenario.add_asset("B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]), patch_attr)                        patchIDs.append("B"+str(bID)+"_PatchID"+str(blockpatches[p]["PatchID"]))                    current_block.add_attribute("PatchIDs", patchIDs)   # Used later to map other attributes to patches                else:                    current_block.add_attribute("PatchIDs", [])     # If no patches, empty list!        else:            landuseraster = None    # Indicate that the simulation has no land use data, limits what can be done            luc_res = None            map_attr.set_attribute("HasLUC", 0)            map_attr.add_attribute("HasSPATIALMETRICS", 0)        # STEP 2.3 :: Load Population Map        if self.population_map:            pop_dref = self.datalibrary.get_data_with_id(self.population_map)   # Retrieve the population data reference            fullfilepath = pop_dref.get_data_file_path() + pop_dref.get_metadata("filename")            self.notify("Loading: " + str(fullfilepath))            print("Loading: " + str(fullfilepath))            populationraster = ubspatial.import_ascii_raster(fullfilepath, self.population_map)            self.notify("Load Complete!")            print("Load Complete!")            population_offset = ubspatial.calculate_offsets(populationraster, map_attr)            pop_res = populationraster.get_cellsize()            csc = int(math.ceil(bs / pop_res))  # csc = cell selection count - knowing how many cells wide and tall            # STEP 2.4 :: ASSIGN POPULATION TO BLOCKS            for i in range(len(blockslist)):                current_block = blockslist[i]                originXY = [current_block.get_attribute("OriginX"), current_block.get_attribute("OriginY")]                col_origin = int(originXY[0] / pop_res)                col_start_adj, cscx = ubspatial.adjust_position_by_offset(col_origin, population_offset[0], csc)                row_origin = int(originXY[1] / pop_res)                row_start_adj, cscy = ubspatial.adjust_position_by_offset(row_origin, population_offset[1], csc)                popdatamatrix = populationraster.get_data_square(col_start_adj, row_start_adj, cscx, cscy)                # STEP 2.4.1 - Tally up total population                popfactor = 1.0                if pop_dref.get_metadata("sub") == "Density":                    popfactor = (float(pop_res) * float(pop_res)) / 10000.0   # Area of a single cell (persons/ha)                elif pop_dref.get_metadata("sub") == "Count":                    popfactor = 1.0   # No multiplication                pop_values = popdatamatrix.flatten()    # Flatten to a single array                pop_values[pop_values == populationraster.get_nodatavalue()] = 0    # Remove all no-data values                total_population = float(sum(pop_values) * popfactor)                current_block.add_attribute("Population", int(total_population))                map_attr.add_attribute("HasPOP", 1)                # STEP 2.4.2 - Map Population Data to Patches if they exist                if self.patchdelin and self.landuse_map:     # Assign population values to patches                    mapXY = [col_origin * pop_res, row_origin * pop_res]                    patchIDs = current_block.get_attribute("PatchIDs")                    for p in range(len(patchIDs)):                        # Step 1 - Get the Patch Object                        patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))                        # Step 2 - Extract the data from the map                        popdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, pop_res,                                                                            patch_obj, popdatamatrix)                        # Step 3 - Summarise the data for the patch and write to attributes                        if len(popdata) == 0:                            patch_obj.add_attribute("Population", 0)                        else:                            popdata[popdata == populationraster.get_nodatavalue()] = 0   # Remove all no-data values                            patch_obj.add_attribute("Population", int(sum(popdata) * popfactor))        else:            populationraster = None     # Indicates that the simulation has no population data, limits features            map_attr.set_attribute("HasPOP", 0)        # STEP 2.5 :: Load Elevation Map        if self.elevation_map:            elev_dref = self.datalibrary.get_data_with_id(self.elevation_map)     # Retrieves the elevation data ref            fullfilepath = elev_dref.get_data_file_path() + elev_dref.get_metadata("filename")            self.notify("Loading: " + str(fullfilepath))            print("Loading: " + str(fullfilepath))            elevationraster = ubspatial.import_ascii_raster(fullfilepath, self.elevation_map)            self.notify("Load Complete!")            print("Load Complete!")            elevation_offset = ubspatial.calculate_offsets(elevationraster, map_attr)            elev_res = elevationraster.get_cellsize()            csc = int(math.ceil(bs / elev_res))    # Figure out how many cells wide and cells tall in elevation raster            # STEP 2.6 :: ASSIGN ELEVATION TO BLOCKS            for i in range(len(blockslist)):                current_block = blockslist[i]                if current_block.get_attribute("Status") == 0:                    continue    # If block has Status == 0, skip                originXY = [current_block.get_attribute("OriginX"), current_block.get_attribute("OriginY")]                col_origin = int(originXY[0] / elev_res)                col_start_adj, cscx = ubspatial.adjust_position_by_offset(col_origin, elevation_offset[0], csc)                row_origin = int(originXY[1] / elev_res)                row_start_adj, cscy = ubspatial.adjust_position_by_offset(row_origin, elevation_offset[1], csc)                elevdatamatrix = elevationraster.get_data_square(col_start_adj, row_start_adj, cscx, cscy)                # STEP 2.6.1 - Calculate elevation metrics for the Block                elevationpoints = []                for row in range(len(elevdatamatrix)):                    for col in range(len(elevdatamatrix[0])):                        if elevdatamatrix[row, col] == elevationraster.get_nodatavalue():                            continue                        else:                            elevationpoints.append(float(elevdatamatrix[row, col]))                if len(elevationpoints) == 0:                    current_block.set_attribute("Status", 0)                else:                    current_block.set_attribute("Status", 1)                    current_block.add_attribute("AvgElev", sum(elevationpoints)/max(float(len(elevationpoints)), 1.0))                    current_block.add_attribute("MaxElev", max(elevationpoints))                    current_block.add_attribute("MinElev", min(elevationpoints))                    map_attr.add_attribute("HasELEV", 1)                # STEP 2.6.2 - Map elevation data onto Block Patches                if self.patchdelin and self.landuse_map:                    if current_block.get_attribute("Status") == 0:                        patchIDs = current_block.get_attribute("PatchIDs")                        if patchIDs is None:                            pass                        else:                            for p in range(len(patchIDs)):      # If the current Block's status is zero, switch all patches                                patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))     # to zero as well.                                patch_obj.change_attribute("Status", 0)                    else:                        mapXY = [col_origin * elev_res, row_origin * elev_res]                        patchIDs = current_block.get_attribute("PatchIDs")                        for p in range(len(patchIDs)):                            # Step 1 - Get the Patch Object                            patch_obj = self.scenario.get_asset_with_name(str(patchIDs[p]))                            # Step 2 - Extract the data from the map                            elevdata = ubmethods.extract_data_for_patch_from_map(originXY, luc_res, mapXY, elev_res,                                                                                 patch_obj, elevdatamatrix)                            # Step 3 - Summarise the data for the patch and write to attributes                            elevdata_clean = []                            for e in range(len(elevdata)):                                if elevdata[e] == elevationraster.get_nodatavalue():                                    continue                                elevdata_clean.append(elevdata[e])                            try:                                patch_obj.add_attribute("Elevation", float(sum(elevdata_clean)/len(elevdata_clean)))                            except ZeroDivisionError:                                patch_obj.add_attribute("Elevation", current_block.get_attribute("AvgElev"))                                # If no elevation data avaiable, set it to the current Block's elevation data        else:            elevationraster = None  # Indicates that the simulation has no elevation data, many water features disabled            map_attr.set_attribute("HasELEV", 0)        # - STEP 3 - FIND BLOCK NEIGHBOURHOOD        self.notify("Establishing neighbourhoods")        print("Establishing neighbourhoods")        for i in range(len(blockslist)):  # Loop across current Blocks            curblock = blockslist[i]    # curblock is the reference to the UBVector() instance in blockslist            if curblock.get_attribute("Status") == 0:                continue    # If the block has zero status, don't consider            curblock_id = curblock.get_attribute("BlockID")            nhd = []    # Will contain all block IDs in the Neighbourhood (nhd)            for j in range(len(blockslist)):  # Loop across blocks again                comp_block_id = blockslist[j].get_attribute("BlockID")                if comp_block_id == curblock_id or blockslist[j].get_attribute("Status") == 0:                    # If the IDs are identical or the Block has zero status, then skip                    continue                if nhd_type == 8:  # 8 neighbours, search based on points                    if curblock.shares_geometry(blockslist[j], "points"):                        nhd.append(comp_block_id)                elif nhd_type == 4:  # 4 neighbours, search based on edges                    if curblock.shares_geometry(blockslist[j], "edges"):                        nhd.append(comp_block_id)            curblock.add_attribute("Neighbours", nhd)  # ATTRIBUTE: neighbourhood type<list> - [ Block IDs ]        # - STEP 4 - Assign Municipal Regions and Suburban Regions to Blocks        municipalities = []        self.notify("Loading Municipality Map")        print("Loading Municipality Map")        if self.include_geopolitical:                       # LOAD MUNICIPALITY MAP            map_attr.add_attribute("HasGEOPOLITICAL", 1)            geopol_map = self.datalibrary.get_data_with_id(self.geopolitical_map)            fullfilepath = geopol_map.get_data_file_path() + geopol_map.get_metadata("filename")            municipalities = ubspatial.import_polygonal_map(fullfilepath, "native", "Municipality",                                                            (map_attr.get_attribute("xllcorner"),                                                             map_attr.get_attribute("yllcorner")))            for i in range(len(municipalities)):                self.scenario.add_asset(municipalities[i].get_attribute("Map_Naming"), municipalities[i])        else:            map_attr.add_attribute("HasGEOPOLITICAL", 0)        suburbs = []        self.notify("Loading Suburb Map")        print("Loading Suburb Map")        if self.include_suburb:                             # LOAD SUBURBAN MAP            map_attr.add_attribute("HasSUBURBS", 1)            suburb_map = self.datalibrary.get_data_with_id(self.suburban_map)            fullfilepath = suburb_map.get_data_file_path() + suburb_map.get_metadata("filename")            suburbs = ubspatial.import_polygonal_map(fullfilepath, "native", "Suburb",                                                     (map_attr.get_attribute("xllcorner"),                                                      map_attr.get_attribute("yllcorner")))            for i in range(len(suburbs)):                self.scenario.add_asset(suburbs[i].get_attribute("Map_Naming"), suburbs[i])        else:            map_attr.add_attribute("HasSUBURBS", 0)        planzones = []        self.notify("Loading Planning Zones Map")        print("Loading Planning Zones Map")        if self.include_planzone:  # LOAD SUBURBAN MAP            map_attr.add_attribute("HasPLANZONES", 1)            planzone_map = self.datalibrary.get_data_with_id(self.planzone_map)            fullfilepath = planzone_map.get_data_file_path() + planzone_map.get_metadata("filename")            planzones = ubspatial.import_polygonal_map(fullfilepath, "native", "Planning Zones",                                                     (map_attr.get_attribute("xllcorner"),                                                      map_attr.get_attribute("yllcorner")))            for i in range(len(suburbs)):                self.scenario.add_asset(planzones[i].get_attribute("Map_Naming"), planzones[i])        else:            map_attr.add_attribute("HasPLANZONES", 0)        # Check intersection with blocks - assign the municipality, suburb and planning zones based on Block Centroid        for i in range(len(blockslist)):            current_block = blockslist[i]            coordinates = current_block.get_points()            # List comprehension: creates a list of coordinates with only            # x, y points. I.e. removes the Z-coordinate            coordinates = [c[:2] for c in coordinates]            blockpoly = Polygon(coordinates)            # Keep searching (search = 1), block Centroid within municipality and suburb? Until found (search = 0)            intersectarea = 0            intersectname = ""            for m in municipalities:                featpoly = Polygon(m.get_points())                if not featpoly.intersects(blockpoly):  # If there is no intersection...                    continue                newisectionarea = featpoly.intersection(blockpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.geopolitical_attref)            if intersectname != "" and intersectarea > 0:                current_block.add_attribute("Region", intersectname)            else:                current_block.add_attribute("Region", "Unassigned")            intersectarea = 0            intersectname = ""            for m in suburbs:                featpoly = Polygon(m.get_points())                if not blockpoly.intersects(featpoly):                    continue                newisectionarea = blockpoly.intersection(featpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.suburban_attref)            if intersectname != "" and intersectarea > 0:                current_block.add_attribute("Suburb", intersectname)            else:                current_block.add_attribute("Suburb", "Unassigned")            intersectarea = 0            intersectname = ""            for m in planzones:                featpoly = Polygon(m.get_points())                if not blockpoly.intersects(featpoly):                    continue                newisectionarea = blockpoly.intersection(featpoly).area                if newisectionarea > intersectarea:                    intersectarea = newisectionarea                    intersectname = m.get_attribute(self.planzone_attref)            if intersectname != "" and intersectarea > 0:                current_block.add_attribute("PlanZone", intersectname)            else:                current_block.add_attribute("PlanZone", "Unassigned")        # - STEP 5 - Load Rivers, Lakes and built infrastructure, assign to Blocks and calculate closest distance        # STEP 5.1 :: Grab maps and assign their data to Blocks        if self.include_rivers:            map_attr.add_attribute("HasRIVERS", 1)            river_map = self.datalibrary.get_data_with_id(self.river_map)            self.notify("Loading River Map")            print("Loading River Map")            fullfilepath = river_map.get_data_file_path() + river_map.get_metadata("filename")            rivers = ubspatial.import_linear_network(fullfilepath, "LINES",                                                     (map_attr.get_attribute("xllcorner"),                                                      map_attr.get_attribute("yllcorner")))            self.detect_rivers_in_blocks(blockslist, rivers)        else:            map_attr.add_attribute("HasRIVERS", 0)        if self.include_lakes:            map_attr.add_attribute("HasLAKES", 1)            lake_map = self.datalibrary.get_data_with_id(self.lake_map)            self.notify("Loading Lakes Map")            print("Loading Lakes Map")            fullfilepath = lake_map.get_data_file_path() + lake_map.get_metadata("filename")            lakes = ubspatial.import_polygonal_map(fullfilepath, "native", "Lake",                                                   (map_attr.get_attribute("xllcorner"),                                                    map_attr.get_attribute("yllcorner")))            self.detect_lakes_in_blocks(blockslist, lakes)        else:            map_attr.add_attribute("HasLAKES", 0)        # STEP 5.2 :: Calculate distance to closest water body if the user wants        if self.calculate_wbdistance:            self.calculate_closest_waterbody(blockslist)        # STEP 5.3 :: Load other built infrastructure data        if self.include_storm:      # Their sole purpose is to support the delineation of stormwater flow paths            map_attr.add_attribute("HasSTORMDRAINS", 1)            storm_map = self.datalibrary.get_data_with_id(self.storm_map)            self.notify("Loading Storm Drains")            print("Loading Storm Drains")            fullfilepath = storm_map.get_data_file_path() + storm_map.get_metadata("filename")            stormdrains = ubspatial.import_linear_network(fullfilepath, "LINES",                                                          (map_attr.get_attribute("xllcorner"),                                                           map_attr.get_attribute("yllcorner")))            self.detect_stormdrains_in_blocks(blockslist, stormdrains)        else:            map_attr.add_attribute("HasSTORMDRAINS", 0)        # - STEP 6 - Calculate topography (slope/aspect), delineate Flow Paths and Drainage Basins        # STEP 6.1 :: Calculate slope and aspect        if map_attr.get_attribute("HasELEV"):            # Calculate slope and aspect            self.notify("Calculating slope and aspect for each Block")            print("Calculating slope and aspect for each Block")            if self.dem_smooth:     # If the user wishes to smooth the DEM, then perform the smoothing passes                self.perform_smooth_dem(blockslist)            self.calculate_slope_aspect_for_blocks(blockslist, map_attr, elevationraster.get_nodatavalue())        if map_attr.get_attribute("HasELEV") and self.flowpaths:            # Delineate flow paths            self.notify("Delineating flow paths and drainage sub-basins")            print("Delineating flow paths and drainage sub-basins")            self.delineate_flow_paths(blockslist, map_attr)     # Delineates the flow directions            totalbasins = self.delineate_basin_structures(blockslist)   # Delineates the sub-catchments            # Write details to map attributes            map_attr.add_attribute("TotalBasins", totalbasins)            map_attr.add_attribute("HasFLOWPATHS", 1)        else:            map_attr.add_attribute("HasFLOWPATHS", 0)        # - STEP 7 Delineate Patch Flow Paths        if self.patchdelin and self.patchflowpaths and self.elevation_map and self.landuse_map:            self.notify("Delineating flow paths among patches")            print ("Delineating flow paths among patches")            self.delineate_patch_flow_paths()            map_attr.add_attribute("HasPATCHFLOW", 1)        else:            map_attr.add_attribute("HasPATCHFLOW", 0)        # - STEP 8 - Spatial Connectivity        if self.patchdelin:            green_patches, grey_patches, non_patches = self.retrieve_patch_groups()            if len(green_patches) > 0:                # 7.1 - Open Space Distances                if self.osnet_accessibility:                    self.notify("Analysing open space accessibility")                    print("Analysing open space accessibility")                    self.find_open_space_distances(green_patches, grey_patches, non_patches)                    map_attr.add_attribute("HasOSLINK", 1)                else:                    map_attr.add_attribute("HasOSLINK", 0)                # 7.2 - Open Space Network                if self.osnet_network:                    self.notify("Analysing open space network")                    print("Analysing open space network")                    # The minimum acceptable distance to connect the network is taken as the final block size, if two                    # entire Block patches exist, they are adjacent and connected by Block centroid                    min_dist = self.final_bs*math.sqrt(2)                    self.delineate_open_space_network(green_patches, grey_patches, non_patches, min_dist)                    map_attr.add_attribute("HasOSNET", 1)                else:                    map_attr.add_attribute("HasOSNET", 0)            else:                self.notify("Warning, no open spaces in map, cannot check for links")                map_attr.add_attribute("HasOSLINK", 0)                map_attr.add_attribute("HasOSNET", 0)        # - CLEAN-UP - RESET ALL VARIABLES FOR GARBAGE COLLECTOR        self.notify("End of Delinblocks")        print("End of Delinblocks")        return False    # ------------------------------------------------    # |-    ADDITIONAL MODULE FUNCTIONS             -|    # ------------------------------------------------    def calculate_slope_aspect_for_blocks(self, blocklist, map_attr, nodata):        """Calculates the slope and aspect attributes for each Block in the map. Saves three attributes to each Block,        Slope in %, Slope in Degrees, Aspect in degrees on compass rose from North.        :param blocklist: the list of UrbanBEATS Block UBVector() instances.        :param map_attr: the map attributes UBComponent() instance with relevant global information.        :param nodata: the no-data value of the original data set, so that the model knows how to navigate missing vals.        :return: Writes three attributes to each Block.        """        bs = map_attr.get_attribute("BlockSize")        for i in range(len(blocklist)):            if blocklist[i].get_attribute("Status") == 0:                continue            curblock = blocklist[i]            z_central = curblock.get_attribute("AvgElev")            nhd = curblock.get_attribute("Neighbours")            z_nhd = [nodata, nodata, nodata, nodata, nodata, nodata, nodata, nodata]    #[N, NE, E, SE, S, SW, W, NW]            for j in nhd:                n_block = self.scenario.get_asset_with_name("BlockID"+str(j))                # Figure out cardinal direction                if curblock.get_attribute("CentreX") > n_block.get_attribute("CentreX"):                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> SW                        d_index = 5     # South-West                    elif curblock.get_attribute("CentreY") == n_block.get_attribute("CentreY"):     # --> W                        d_index = 6     # West                    else:                        d_index = 7     # North-West because Centre Y of centre is less                elif curblock.get_attribute("CentreX") == n_block.get_attribute("CentreX"):                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> S                        d_index = 4     # South                    elif curblock.get_attribute("CentreY") < n_block.get_attribute("CentreY"):      # --> N                        d_index = 0     # North                    else:                        d_index = 0                        print "SOMETHING IS WRONG - SLOPE ASPECT CALCULATIONS!!"        # n_block == curblock                else:   # curblock Centre X < n_block Centre X                    if curblock.get_attribute("CentreY") > n_block.get_attribute("CentreY"):    # --> SE                        d_index = 3     # South-East                    elif curblock.get_attribute("CentreY") < n_block.get_attribute("CentreY"):  # --> NE                        d_index = 1     # North-East                    else:   #  --> E                        d_index = 2     # East                z_nhd[d_index] = n_block.get_attribute("AvgElev")            # Calculate Slope and Aspect            slope_rad, slope_deg = ubmethods.calculate_slope(z_central, z_nhd, bs, bs, nodata)            curblock.add_attribute("Slope_PCT", round(slope_rad * 100, 2))            curblock.add_attribute("Slope_DEG", round(slope_deg, 2))            aspect_deg = ubmethods.calculate_aspect(z_central, z_nhd, nodata)            curblock.add_attribute("Aspect_DEG", aspect_deg)        return True    def delineate_patch_flow_paths(self):        """Delineates the flowpaths for the patches based on the selected method. Function creates links in UBVector()        format and saves them to the active scenario. Patch attributes are updated as well."""        if self.patchsearchauto:            searchradius = self.blocksize * 1.4     # 1.4 x Block Size        else:            searchradius = max(float(self.blocksize), float(self.patchsearchradius))  # Maximum of Blocksize never less!        patches = self.scenario.get_assets_with_identifier("PatchID")  # Retrieves all patches        idcounter = 1        for curpatch in patches:            if curpatch.get_attribute("Status") == 0:                continue    # SKIP CONDITION #1 - Patch is not active, skip            z1 = curpatch.get_attribute("Elevation")            dz = []   # [ dz, dist, UBVector(), points tuple ]            pts1 = curpatch.get_points()            for nextpatch in patches:                if nextpatch.get_attribute("Status") == 0:                    continue    # SKIP CONDITION #0 - the next patch has no status                if nextpatch.get_attribute("PatchName") == curpatch.get_attribute("PatchName"):                    continue    # SKIP CONDITION #2 - Patches are equal, skip                pts2 = nextpatch.get_points()                current_dist = math.sqrt(pow(pts1[0] - pts2[0], 2) + pow(pts1[1] - pts2[1], 2))                if current_dist > searchradius:                    continue    # SKIP CONDITION #3 - Not within search radius                z2 = nextpatch.get_attribute("Elevation")                if z2 - z1 >= 0: # SKIP CONDITION #4 - Not lower elevation than current patch                    continue    # Not downstream                dz.append([z2-z1, current_dist, nextpatch, pts2])            # Now pick from the list and find the lower patch point            if len(dz) == 0:                curpatch.add_attribute("downPatch", "-1")                curpatch.add_attribute("downDist", 0)                curpatch.add_attribute("down_dz", 0)                continue            if self.patchflowmethod == "MAX":                dz.sort()            elif self.patchflowmethod == "MIN":                dz.sort(reverse=True)            elif self.patchflowmethod == "DIST":                dz.sort(key=lambda x: x[1])            downPatch = dz[0][2]  # first row, 2nd column            # print "Located down patch", dz[0]            curpatch.add_attribute("downPatch", str(downPatch.get_attribute("PatchName")))            curpatch.add_attribute("downDist", float(dz[0][1]))            curpatch.add_attribute("down_dz", float(dz[0][0]))            # Create the Link            link = ubdata.UBVector((curpatch.get_points(), dz[0][3]))            link.add_attribute("PatchFloID", idcounter)            link.add_attribute("Upstream", curpatch.get_attribute("PatchName"))            link.add_attribute("Downstream", downPatch.get_attribute("PatchName"))            link.add_attribute("Distance", dz[0][1])            link.add_attribute("dZ", dz[0][0])            self.scenario.add_asset("PatchFloID"+str(idcounter), link)            idcounter += 1        return True    def find_open_space_distances(self, green_patches, grey_patches, non_patches):        """Calculates the location of the closest green space within the map. Considers PG and REF land uses. Distances        are calculated between the grey patches, which is a list of non-park patches and green patches.        :param green_patches: list containing UBVector() instances of all PG/REF patches in the map        :param grey_patches: list containing UBVector() instances fo all non PG/REF patches        :param non_patches: list containing UBVector() instances fo all patches that should not be considered        :return: Modifies the existing patch UBVector() instance and adds OSLink assets to the scenario        """        # Find the distance to nearest green space in all grey patches        oslink_id = 1        for grey in grey_patches:            prev_dist = 9999999999999999    # Initialize            pts_current = (0, 0)        # Initialize            current_green = None     # Initialize            pts1 = grey.get_points()            for green in green_patches:                pts2 = green.get_points()                current_dist = math.sqrt(pow(pts1[0] - pts2[0], 2) + pow(pts1[1] - pts2[1],2))                if current_dist < prev_dist:                    prev_dist = current_dist                    pts_current = pts2                    current_green = green                    grey.add_attribute("GSD_Dist", prev_dist)                    grey.add_attribute("GSD_Loc", str(green.get_attribute("BlockID"))+"_"+                                       str(green.get_attribute("PatchID")))                    grey.add_attribute("GSD_Deg", 0)                    grey.add_attribute("GSD_ACon", 0)            # Draw the link line            dist_line = ubdata.UBVector(((pts1[0], pts1[1]), (pts_current[0], pts_current[1])))            dist_line.add_attribute("OSLinkID", oslink_id)            dist_line.add_attribute("Distance", prev_dist)            dist_line.add_attribute("Location", grey.get_attribute("GSD_Loc"))            dist_line.add_attribute("Landuse", grey.get_attribute("Landuse"))            dist_line.add_attribute("AreaAccess", grey.get_attribute("PatchArea"))            dist_line.add_attribute("OS_Size", current_green.get_attribute("PatchArea"))            self.scenario.add_asset("OSLinkID"+str(oslink_id), dist_line)            oslink_id += 1        # For all green patches, write the same attributes and calculate the degree of connection        for green in green_patches:            patch_name = str(green.get_attribute("BlockID"))+"_"+str(green.get_attribute("PatchID"))            degree = 0            urban_area_connected = 0            for grey in grey_patches:                if grey.get_attribute("GSD_Loc") == patch_name:                    degree += 1                    urban_area_connected += grey.get_attribute("PatchArea")            green.add_attribute("GSD_Dist", 0)            green.add_attribute("GSD_Loc", str(green.get_attribute("BlockID"))+"_"+                                str(green.get_attribute("PatchID")))            green.add_attribute("GSD_Deg", degree)            green.add_attribute("GSD_ACon", urban_area_connected)        # For non-patches, add all default attributes        for non in non_patches:            non.add_attribute("GSD_Dist", -1)            non.add_attribute("GSD_Loc", "")            non.add_attribute("GSD_Deg", 0)            non.add_attribute("GSD_ACon", 0)        return True    def retrieve_patch_groups(self):        """Scans the simulation's patches and subdivides them into three groups based on land use. Returns three lists,        each containing all references to UBVector() objects with corresponding patch type.        :return: greenpatches (list of all PG and REF land use patchs), roadpatches (list of all RD patches), and                 greypathces (everything else)        """        # Get all patches in the collection        patches = self.scenario.get_assets_with_identifier("PatchID")     # Retrieves all patches        # From all the patches, sort out the open space patches as a separate array        greenpatches = []        greypatches = []        roadpatches = []        for i in patches:            if i.get_attribute("Landuse") in [10, 11]:                greenpatches.append(i)            elif i.get_attribute("Landuse") in [8]:                roadpatches.append(i)            else:                greypatches.append(i)        return greenpatches, greypatches, roadpatches    def delineate_open_space_network(self, green_patches, grey_patches, non_patches, min_dist):        """Create a network of open spaces, only considers Parks and Reserves/Floodways        :param green_patches: a list containing UBVector() instances of green patches        :param grey_patches: a list of UBVector() instances of grey patches        :param non_patches: a list of UBVector() instances representing road patches        :return: modifies the existing patch data and adds OSNet assets to the scenario        """        osnet_id = 1        for g in green_patches:             # For each green patch, find the next closest patch            degrees = 0            pts1 = g.get_points()   # Get the patchXY            prev_dist = -1            for h in green_patches:                if h.get_attribute("BlockID") == g.get_attribute("BlockID") \                        and h.get_attribute("PatchID") == g.get_attribute("PatchID"):                    continue    # If it's the same patch, don't do anything!!                pts2 = h.get_points()                current_dist = math.sqrt(pow(pts1[0]-pts2[0], 2) + pow(pts1[1]-pts2[1], 2))                if current_dist <= min_dist:                    degrees += 1                    link = ubdata.UBVector(((pts1[0], pts1[1]), (pts2[0], pts2[1])))                    link.add_attribute("OSNetID", osnet_id)                    link.add_attribute("NodeA", str(g.get_attribute("BlockID")) + "_" +                                       str(g.get_attribute("PatchID")))                    link.add_attribute("NodeB", str(h.get_attribute("BlockID")) + "_" +                                       str(h.get_attribute("PatchID")))                    link.add_attribute("Distance", current_dist)                    self.scenario.add_asset("OSNetID" + str(osnet_id), link)                    osnet_id += 1                    if prev_dist == -1 or current_dist < prev_dist:                        prev_dist = current_dist            g.add_attribute("OSNet_Deg", degrees)            g.add_attribute("OSNet_MinD", prev_dist)        # Add the new attributes to all patches that aren't parks for completeness        for g in grey_patches:            g.add_attribute("OSNet_Deg", 0)            g.add_attribute("OSNet_MinD", -1)        for n in non_patches:            n.add_attribute("OSNet_Deg", 0)            n.add_attribute("OSNet_MinD", -1)        return True    def calculate_closest_waterbody(self, blockslist):        """Calculates the distance to the closest water body and the location of the closest water body.        :param blockslist: The list of active Blocks (UBVector() instances) within the simulation        :return: updates each Block with the "WBloc" and "WBdist" attributes.        """        wb_blocks = []        # Step 1 - Determine all river and lake blocks and set their distances to zero and their location to their own        for b in blockslist:            if b.get_attribute("HasRiver") or b.get_attribute("HasLake"):                b.add_attribute("WBdist", 0)                b.add_attribute("WBloc", b.get_attribute("BlockID"))                wb_blocks.append(b)     # Append this block to a list of water body blocks for scanning later        # Step 2 - Now calculate for all remaining blocks these distances and locations        for b in blockslist:            if b.get_attribute("HasRiver") or b.get_attribute("HasLake"):                continue            else:                prev_distance = 9999999999.9                bx = b.get_attribute("CentreX")                by = b.get_attribute("CentreY")                for c in wb_blocks:                    # Calculate distances from Block Centroids                    cx = c.get_attribute("CentreX")                    cy = c.get_attribute("CentreY")                    cur_distance = math.sqrt(pow(cx-bx, 2) + pow(cy-by, 2))                    if cur_distance < prev_distance:                        prev_distance = cur_distance                        b.add_attribute("WBdist", cur_distance)                        b.add_attribute("WBloc", c.get_attribute("BlockID"))        return True    def detect_lakes_in_blocks(self, blockslist, lakeslist):        """Intersects all blocks with all lakes and transfers lake name to each Block.        :param blockslist: the list of active Blocks in the simulation        :param lakeslist: loaded UBVector() objects of lake polygons.        :return: modifies the existing UBVector() Block objects with "HasLake" and "LakeNames" attributes.        """        for i in range(len(blockslist)):            curblock = blockslist[i]            if curblock.get_attribute("Status") == 0:                continue            coordinates = curblock.get_points()            coordinates = [c[:2] for c in coordinates]            blockpoly = Polygon(coordinates)            haslake = 0            lakenames = []            for j in range(len(lakeslist)):                lakepoly = Polygon(lakeslist[j].get_points())                if not lakepoly.intersects(blockpoly):                    continue                lakename = lakeslist[j].get_attribute(self.lake_attname)                if lakename not in lakenames:                    lakenames.append(lakename)                haslake = 1            if haslake:                curblock.add_attribute("HasLake", 1)                curblock.add_attribute("LakeNames", lakenames)            else:                curblock.add_attribute("HasLake", 0)                curblock.add_attribute("LakeNames", [])        return True    def detect_rivers_in_blocks(self, blockslist, riverslist):        """Intersects all Blocks with all rivers and transfers river information to each Block.        :param blockslist: the list of active Blocks in the simulation        :param riverslist: loaded UBVector() objects of rivers.        :return: modifies all existing UBVector() Block Objects with "HasRiver" and "RiverNames" attributes.        """        for i in range(len(blockslist)):            curblock = blockslist[i]            if curblock.get_attribute("Status") == 0:                continue            coordinates = curblock.get_points()            coordinates = [c[:2] for c in coordinates]            blockpoly = Polygon(coordinates)            hasriver = 0            rivernames = []            for j in range(len(riverslist)):                path = LineString(riverslist[j].get_points())                if not path.intersects(blockpoly):                    continue                # If the current linestring intersects with the Block, then...                rivername = riverslist[j].get_attribute(self.river_attname)                if rivername not in rivernames:                    rivernames.append(rivername)                hasriver = 1            if hasriver:                curblock.add_attribute("HasRiver", 1)                curblock.add_attribute("RiverNames", rivernames)            else:                curblock.add_attribute("HasRiver", 0)                curblock.add_attribute("RiverNames", [])        return True    def detect_stormdrains_in_blocks(self, blockslist, stormdrains):        """Intersects all Blocks with all stormwater drains and transfers drainage information to each Block.        :param blockslist: the list of active Blocks in the simulation        :param stormdrains: loaded UBVector() objects of stormwater drains        :return: modifies all existing UBVector() Block Objects with the "HasSWDrain" attribute.        """        for i in range(len(blockslist)):            curblock = blockslist[i]            if curblock.get_attribute("Status") == 0:                continue            coordinates = curblock.get_points()            coordinates = [(c[0], c[1]) for c in coordinates]            blockpoly = Polygon(coordinates)            hasdrain = 0            for j in range(len(stormdrains)):                path = LineString(stormdrains[j].get_points())                if not path.intersects(blockpoly):                    continue                hasdrain = 1            if hasdrain:                curblock.add_attribute("HasSWDrain", 1)            else:                curblock.add_attribute("HasSWDrain", 0)        return True    def create_block_flow_hashtable(self, blockslist):        """Creates a hash table of BlockIDs for quick lookup, this allows the basin delineation algorithm to rapidly        delineate the sub-catchment        :param blockslist: the list of UBVector() instances of all blocks in the map        :return: a 2D list [ [upstreamID], [downstreamID] ]        """        hash_table = [[], []]     # COL#1: BlockID (upstream), COL#2: BlockID (downstream)        for i in range(len(blockslist)):            current_block = blockslist[i]            current_id = current_block.get_attribute("BlockID")            if current_block.get_attribute("Status") == 0:                continue            hash_table[0].append(int(current_id))            hash_table[1].append(int(current_block.get_attribute("downID")))    # [ID or -2]        return hash_table    def delineate_basin_structures(self, blockslist):        """Delineates sub-basins across the entire blocksmap specified by the collection of blocks in 'blockslist'.        Returns the number of sub-basins in the map, but also writes BasinID information to each Block. Delineation is        carried out by creating a hash table of BlockID and downstream ID.        Each block is scanned and all its upstream and downstream Block IDs identified, each is also assigned a        BasinID.        :param blocklist: the list [] of UBVector() instances that represent Blocks        :return: number of total basins. Also writes the "BasinID" attribute to each Block.        """        hash_table = self.create_block_flow_hashtable(blockslist)    # Start by creating a hash tables        basin_id = 0    # Set Basin ID to zero, it will start counting up as soon as basins are found        for i in range(len(blockslist)):    # Loop  across all Blocks            current_block = blockslist[i]            if current_block.get_attribute("Status") == 0:                continue    # Skip if Status = 0            # Check if the Block is a single-basin Block            current_id = current_block.get_attribute("BlockID")            if current_id not in hash_table[1]:                 # If the current Block not downstream of something...                current_block.add_attribute("UpstrIDs", [])     # ...then it has NO upstream IDs (empty list)                if current_id in hash_table[0]:                 # ... if it is in the first column of the hash table                    if hash_table[1][hash_table[0].index(current_id)] == -2:    # if its second column is -2                        self.notify("Found a single block basin at BlockID"+str(current_id))                        basin_id += 1   # Then we have found a single-block Basin                        current_block.add_attribute("BasinID", basin_id)                        current_block.add_attribute("DownstrIDs", [])                        current_block.add_attribute("Outlet", 1)                        continue            # Search the current Block for its upstream IDs            upstream_ids = [current_id]         # Otherwise current ID DOES have upstream blocks            for uid in upstream_ids:             # Begin scanning! Note that upstream_ids will grow in length!                for j in range(len(hash_table[1])):                    if uid == hash_table[1][j]:                        if hash_table[0][j] not in upstream_ids:    # Only want unique upstream_ids!                            upstream_ids.append(hash_table[0][j])   # Slowly append more IDs to the hash_table            # Once scan is complete, remove the current Block's ID from the list as it is NOT upstream of itself.            upstream_ids.remove(current_id)            self.notify("BlockID"+str(current_id)+" Upstream: "+str(upstream_ids))            current_block.add_attribute("UpstrIDs", upstream_ids)            # Repeat the whole process now for the downstream IDs            downstream_ids = [current_id]            for uid in downstream_ids:                for j in range(len(hash_table[0])):                    if uid == hash_table[0][j]:                        if hash_table[1][j] not in downstream_ids:                            downstream_ids.append(hash_table[1][j])            # Once scan is complete, remove the current Block's ID from the list as it is NOT downstream of itself.            downstream_ids.remove(current_id)            # downstream_ids.remove(-2)   # Also remove the -2, which is specified if the Outlet Block is found            self.notify("BlockID"+str(current_id)+" DownstreamL "+str(downstream_ids))            current_block.add_attribute("DownstrIDs", downstream_ids)            # Now assign Basin IDs, do this if the current Block has downstream ID -2            if hash_table[1][hash_table[0].index(current_id)] == -2:    # If the block is an outlet                # print "Found a basin outlet at BlockID" + str(current_id)                self.notify("Found a basin outlet at BlockID"+str(current_id))                basin_id += 1                current_block.add_attribute("BasinID", basin_id)    # Set the current Basin ID                current_block.add_attribute("Outlet", 1)            # Outlet = TRUE at current Block                for j in upstream_ids:                    upblock = self.scenario.get_asset_with_name("BlockID"+str(int(j)))                    upblock.add_attribute("BasinID", basin_id)      # Assign basin ID to all upstream blocks                    upblock.add_attribute("Outlet", 0)              # Upstream blocks are NOT outlets!        self.notify("Total Basins in the Case Study: "+str(basin_id))        print("Total Basins in the Case Study: " + str(basin_id))        return basin_id     # The final count indicates how many basins were found    def delineate_flow_paths(self, blockslist, map_attr):        """Delineates the flow paths according to the chosen method and saves the information to the blocks.        :param blockslist: a list [] of UBVector instances representing the Blocks        :param map_attr:  the global map attributes object        :return: all data is saved to the UBVector instances as new Block data.        """        sink_ids = []        river_blocks = []        lake_ids = []        for i in range(len(blockslist)):            current_block = blockslist[i]            current_blockid = current_block.get_attribute("BlockID")            # SKIP CONDITION 1 - Block has zero status            if current_block.get_attribute("Status") == 0:                continue            # SKIP CONDITION 2 - Block already contains a river            if current_block.get_attribute("HasRiver") and not self.ignore_rivers:                current_block.add_attribute("downID", -2)   # Immediately assign it the -2 value for downID                current_block.add_attribute("max_dz", 0)                current_block.add_attribute("avg_slope", 0)                current_block.add_attribute("h_pond", 0)  # Only for sink blocks will height of ponding h_pond > 0                river_blocks.append(current_block)                continue            # SKIP CONDITION 3 - Block contains a lake            if current_block.get_attribute("HasLake") and not self.ignore_lakes:                current_block.add_attribute("downID", -2)  # Immediately assign it the -2 value for downID                current_block.add_attribute("max_dz", 0)                current_block.add_attribute("avg_slope", 0)                current_block.add_attribute("h_pond", 0)  # Only for sink blocks will height of ponding h_pond > 0                lake_ids.append(current_blockid)                continue            z = current_block.get_attribute("AvgElev")            # Get the neighbouring elevations. This is either the full neighbourhood if we are not using natural or            # built features as a guide, or the full neighbourhood if neither features are in adjacent neighbour blocks.            # Otherwise the neighbour_z array will have only as many options as there are neighbours with natural or            # built features.            if self.guide_natural or self.guide_built:      # If we use natural or built features as a guide, then...                neighbours_z = self.get_modified_neighbours_z(current_block)    # Returns [[BlockID], [Elevation]]                if neighbours_z is None:        # If the current block has no natural or built features adjacent...                    neighbours_z = self.scenario.retrieve_attribute_value_list("Block", "AvgElev",                                                                               current_block.get_attribute(                                                                                   "Neighbours"))            else:                neighbours_z = self.scenario.retrieve_attribute_value_list("Block", "AvgElev",                                                                           current_block.get_attribute("Neighbours"))            # print "Neighbour Z: ", neighbours_z            # Find the downstream block unless it's a sink            if self.flowpath_method == "D8":                flow_id, max_zdrop = self.find_downstream_d8(z, neighbours_z)            elif self.flowpath_method == "DI" and self.neighbourhood == "M":                # Only works for the Moore neighbourhood                flow_id, max_zdrop = self.find_downstream_dinf(z, neighbours_z)            else:                self.flowpath_method = "D8"     # Reset to D8 by default                flow_id, max_zdrop = self.find_downstream_d8(z, neighbours_z)            if flow_id == -9999:     # if no flowpath has been found                sink_ids.append(current_blockid)                downstream_id = -1  # Block is a possible sink. if -2 --> block is a catchment outlet            else:                downstream_id = flow_id            # Grab distances / slope between two Block IDs            if flow_id == -9999:                avg_slope = 0            else:                down_block = self.scenario.get_asset_with_name("BlockID"+str(downstream_id))                dx = current_block.get_attribute("CentreX") - down_block.get_attribute("CentreX")                dy = current_block.get_attribute("CentreY") - down_block.get_attribute("CentreY")                dist = float(math.sqrt((dx * dx) + (dy * dy)))                avg_slope = max_zdrop / dist            # Add attributes            current_block.add_attribute("downID", downstream_id)            current_block.add_attribute("max_dz", max_zdrop)            current_block.add_attribute("avg_slope", avg_slope)            current_block.add_attribute("h_pond", 0)    # Only for sink blocks will height of ponding h_pond > 0            # Draw Networks            if downstream_id != -1 and downstream_id != 0:                network_link = self.draw_flow_path(current_block, 1)                self.scenario.add_asset("FlowID"+str(current_blockid), network_link)        # Unblock the Sinks        self.unblock_sinks(sink_ids)        if map_attr.get_attribute("HasRIVER"):            self.connect_river_blocks(river_blocks)   # [TO DO]        return True    def get_modified_neighbours_z(self, curblock):        """Retrieves the z-values of all adjacent blocks within the current block's neighbourhood accounting for        the presence of drainage infrastructure or natural features.        :param curblock: the current block UBVector() instance        :return: a list of z-values for all the block's neighbours [ [BlockID], [Z-value] ], None otherwise        """        nhd = curblock.get_attribute("Neighbours")        nhd_z = [[],[]]        # Scan neighbourhood for Blocks with Rivers/Lakes        for n in nhd:            nblock = self.scenario.get_asset_with_name("BlockID"+str(n))            if self.guide_natural:                if nblock.get_attribute("HasRiver") or nblock.get_attribute("HasLake"):                    nhd_z[0].append(n)                    nhd_z[1].append(nblock.get_attribute("AvgElev"))            if self.guide_built:                if nblock.get_attribute("HasSWDrain") and n not in nhd_z[0]:                    nhd_z[0].append(n)                    nhd_z[1].append(nblock.get_attribute("AvgElev"))        if len(nhd_z[0]) == 0:            return None        else:            return nhd_z    def connect_river_blocks(self, river_blocks):        """Scans the blocks for those containing a river system and connects them based on adjacency and river        rules.        :param river_blocks: the list () of block UBVector() instances with HasRiver == 1.        :return: Each block is given a new attribute specifying the Block containing a river that it drains into        """        # Connect blocks in logical order, probably based on the linestrings of the river        pass    # Scan block list, if HasRiver true, then check neighbours, if they have river and river name is                # identical, connect, otherwise specify -1 as unconnected        return True # [TO DO]    def unblock_sinks(self, sink_ids):        """Runs the algorithm for scanning all sink blocks and attempting to find a flowpath beyond them.        This function may also identify certain sinks as definitive catchment outlets.        :param blockslist: the list [] of block UBVector instances        :param sink_ids: a list of BlockIDs where a sink is believe to exist based on the flowpath method.        :return: adds new assets to the scenario if a flowpath has been found for the sinks        """        for i in range(len(sink_ids)):            current_sinkid = sink_ids[i]            self.notify("Attemtping to unblock flow from BlockID"+str(current_sinkid))            current_block = self.scenario.get_asset_with_name("BlockID"+str(current_sinkid))            if current_block.get_attribute("HasRiver") or current_block.get_attribute("HasLake"):                # If the Block is a river or lake block, do not attempt to unblock it                current_block.set_attribute("downID", -2)  # signifies that Block is an outlet                continue            z = current_block.get_attribute("AvgElev")            nhd = current_block.get_attribute("Neighbours")            possible_id_drains = []            possible_id_z = []            possibility = 0            for j in nhd:                nhd_blk = self.scenario.get_asset_with_name("BlockID"+str(j))                if nhd_blk.get_attribute("Status") == 0:                    continue    # Continue if nhd block has zero status                nhd_downid = nhd_blk.get_attribute("downID")                if nhd_downid not in [current_sinkid, -1] and nhd_downid not in nhd:                    possible_id_drains.append(j)                    possible_id_z.append(nhd_blk.get_attribute("AvgElev") - z)                    possibility += 1            if possibility > 0:                sink_path = min(possible_id_z)                sink_to_id = possible_id_drains[possible_id_z.index(sink_path)]                current_block.set_attribute("downID", sink_to_id)   # Overwrite -1 to new ID                current_block.set_attribute("h_pond", sink_path)    # If ponding depth > 0, then there was a sink                network_link = self.draw_flow_path(current_block, "Ponded")                self.scenario.add_asset("FlowID" + str(current_block.get_attribute("BlockID")), network_link)            else:                current_block.set_attribute("downID", -2)   # signifies that Block is an outlet        return True    def draw_flow_path(self, current_block, flow_type):        """Creates the flowpath geometry and returns a line asset, which can be saved to the scenario.        :param current_block: current ID of the block that the flowpath is being drawn for        :param flow_type: type of flowpath e.g. "Regular", "Ponded"        :return: UBVector() instance of a network link        """        current_id = current_block.get_attribute("BlockID")        downstream_id = current_block.get_attribute("downID")        down_block = self.scenario.get_asset_with_name("BlockID"+str(downstream_id))        x_up = current_block.get_attribute("CentreX")        y_up = current_block.get_attribute("CentreY")        z_up = current_block.get_attribute("AvgElev")        up_point = (x_up, y_up, z_up)        x_down = down_block.get_attribute("CentreX")        y_down = down_block.get_attribute("CentreY")        z_down = down_block.get_attribute("AvgElev")        down_point = (x_down, y_down, z_down)        network_link = ubdata.UBVector((up_point, down_point))        network_link.determine_geometry((up_point, down_point))        network_link.add_attribute("FlowID", current_id)        network_link.add_attribute("BlockID", current_id)        network_link.add_attribute("DownID", downstream_id)        network_link.add_attribute("Z_up", z_up)        network_link.add_attribute("Z_down", z_down)        network_link.add_attribute("max_zdrop", current_block.get_attribute("max_dz"))        network_link.add_attribute("LinkType", flow_type)        network_link.add_attribute("AvgSlope", current_block.get_attribute("avg_slope"))        network_link.add_attribute("h_pond", current_block.get_attribute("h_pond"))        return network_link    def find_downstream_d8(self, z, nhd_z):        """Uses the standard D8 method to find the downstream neighbouring block. Return the BlockID        and the delta-Z value of the drop. Elevation difference is calculated as dz = [NHD_Z - Z] and is        negative if the neighbouring Block has a lower elevation than the central Block.        :param z: elevation of the current central Block        :param nhd_z: elevation of all its neighbours and corresponding IDs [[IDs], [Z-values]]        :return: down_id: block ID that water drains to, min(dz) the largest elevation difference.        """        dz = []        for i in range(len(nhd_z[1])):            dz.append(nhd_z[1][i] - z)     # Calculate the elevation difference        if min(dz) < 0:    # If there is a drop in elevation - this also means the area cannot be flat!            down_id = nhd_z[0][dz.index(min(dz))]    # The ID corresponds to the minimum elevation difference        else:            down_id = -9999  # Otherwise there is a sink in the current Block        return down_id, min(dz)    def find_downstream_dinf(self, z, nhd_z):        """Adapted D-infinity method to only direct water in one direction based on the steepest slope        of the 8 triangular facets surrounding a Block's neighbourhood and a probabilistic choice weighted        by the propotioning of flow. This is the stochastic option of flowpath delineation for UrbanBEATS        and ONLY works with the Moore neighbourhood.        :param z: elevation of the current central Block        :param nhd_z: :param nhd_z: elevation of all its neighbours and corresponding IDs [[IDs], [Z-values]]        :return:        """        pass    # [TO DO]        # FROM LEGACY CODE        # facetdict = {}  # Stores all the information about the 8 facets        # facetdict["e1"] = ["E", "N", "N", "W", "W", "S", "S", "E"]        # facetdict["e2"] = ["NE", "NE", "NW", "NW", "SW", "SW", "SE", "SE"]        # facetdict["ac"] = [0, 1, 1, 2, 2, 3, 3, 4]        # facetdict["af"] = [1, -1, 1, -1, 1, -1, 1, -1]        # cardin = {"E": 0, "NE": 1, "N": 2, "NW": 3, "W": 4, "SW": 5, "S": 6, "SE": 7}        #        # e0 = currentZ  # CONSTANT PARAMETERS (because of constant block grid and centre point)        # d1 = blocksize        # d2 = d1        # facetangles = [0, math.pi / 4, math.pi / 2, 3 * math.pi / 4, math.pi, 5 * math.pi / 4, 3 * math.pi / 2,        #                7 * math.pi / 4]        #        # # Re-sort the neighbours matrix based on polar angle        # sortedneighb = [neighboursZ[3], neighboursZ[4], neighboursZ[0], neighboursZ[5], neighboursZ[2], neighboursZ[7],        #                 neighboursZ[1], neighboursZ[6]]        # rmatrix = []        # smatrix = []        #        # for i in range(len(sortedneighb)):  # Calculate slopes of all 8 facets        #     currentfacet = i        #        #     e1 = sortedneighb[        #         cardin[facetdict["e1"][currentfacet]]]  # e1 elevation:  (1) get cardinal direction from dictionary,        #     #               (2) get the index from cardin and        #     e2 = sortedneighb[cardin[facetdict["e2"][currentfacet]]]  # (3) get the value from neighbz        #        #     ac = facetdict["ac"][currentfacet]        #     af = facetdict["af"][currentfacet]        #        #     s1 = (e0 - e1) / d1        #     s2 = (e1 - e2) / d2        #     r = math.atan(s2 / s1)        #     s = math.sqrt(math.pow(s1, 2) + math.pow(s2, 2))        #        #     if r < 0:        #         r = 0        #         s = s1        #     elif r > math.atan(d2 / d1):        #         r = math.atan(d2 / d1)        #         s = (e0 - e2) / math.sqrt(math.pow(d1, 2) + math.pow(d2, 2))        #        #     rmatrix.append(r)        #     smatrix.append(s)        #        # # Find the maximum slope and get the angle        # rmax = max(rmatrix)        # rg = af * rmax + ac * math.pi / 2.0        #        # # Find the facet        # for i in range(len(facetangles)):        #     if rg > facetangles[i]:        #         continue        #     else:        #         facet = i - 1        #         theta1 = facetangles[i - 1]        #         theta2 = facetangles[i]        # # Adjust angles based on rg to get proportions        # alpha1 = rg - theta1        # alpha2 = theta2 - rg        # p1 = alpha1 / (alpha1 + alpha2)        # p2 = alpha2 / (alpha2 + alpha1)        #        # print "Proportioned Flows:", p1, p2        #        # if rand.random() < p1:        #     choice = p1        #     directionfacet = int(theta1 / (math.pi / 4))        # else:        #     choice = p2        #     directionfacet = int(theta2 / (math.pi / 4))        #        # print "Choice:", choice        #        # direction = neighboursZ.index(sortedneighb[directionfacet - 1])        # return direction, max_Zdrop        return True    def perform_smooth_dem(self, blockslist):        """Performs a smoothing of the DEM on the Blocks map. This is only necessary if the DEM is quite        tricky to work with and flowpaths are not behaving the way you intend for them to behave.        :param blockslist: a list [] of the block assets in UBVector objects.        """        for i in range(len(self.dem_passes)):            new_elevs = {}            for b in range(len(blockslist)):                current_block = blockslist[i]                elevs = [current_block.get_attribute("Elevation")]                neighbours = current_block.get_attribute("Neighbours")                for n in neighbours:                    ne_block = self.scenario.get_asset_with_name("BlockID"+str(n)).get_attribute("Elevation")                    elevs.append(ne_block)                # print elevs                # print float(sum(elevs)/len(elevs))                new_elevs[str(current_block.get_attribute("BlockID"))] = float(sum(elevs) / len(elevs))            for b in range(len(blockslist)):                blockslist[i].set_attribute("Elevation", new_elevs[str(blockslist[i].get_attribute("BlockID"))])        return True    def create_block_face(self, x, y, bs, ID, boundary):        """Creates the Block Face, the polygon of the block as a UBVector        :param x: The starting x coordinate (on 0,0 origin)        :param y: The starting y coordinate (on 0,0 origin)        :param bs: Block size [m]        :param ID: the current ID number to be assigned to the Block        :param boundary: A Shapely polygon object, used to test if the block face intersects        with it. Also determines whether to save the Block or not.        :return: UBVector object containing the BlockID attribute and geometry        """        # Define points        n1 = (x * bs, y * bs, 0)        # Bottom left (x, y, z)        n2 = ((x + 1) * bs, y * bs, 0)    # Bottom right        n3 = ((x + 1) * bs, (y + 1) * bs, 0)   # Top right        n4 = (x * bs, (y + 1) * bs, 0)    # Top left        # Create the Shapely Polygon and test against the boundary to determine active/inactive.        blockpoly = Polygon((n1[:2], n2[:2], n3[:2], n4[:2]))        if Polygon.intersects(boundary, blockpoly):            # Define edges            e1 = (n1, n2)   # Bottom left to bottom right            e2 = (n2, n3)   # Bottom right to top right            e3 = (n3, n4)   # Top right to top left            e4 = (n4, n1)   # Top left to bottom left            # Define the UrbanBEATS Vector Asset            block_attr = ubdata.UBVector((n1, n2, n3, n4, n1), (e1, e2, e3, e4))            block_attr.add_attribute("BlockID", int(ID))    # ATTRIBUTE: Block Identification            return block_attr        else:            # Block not within boundary, do not return anything            return None